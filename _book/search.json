[
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introdução",
    "section": "",
    "text": "Uma série temporal é uma coleção de variáveis aleatórias indexadas no tempo, ou seja, para o instante \\(t\\), há uma variável \\(X(t)\\) associada.\n\n\n\nFigure 1 - Ilustração de uma série temporal\n\n\nAlguns autores definem séries temporais como uma os valores de uma variável registrados ao longo do tempo. Essa definição não é útil para nós, uma vez que não necessariamente o tempo possui influência na variável, ou seja, é possível que a distribuição de \\(X(t)\\) não dependa de \\(t\\).\n\nImportante: estamos interessados apenas em séries temporais nas quais o modelo de probabilidades depende do tempo \\(t\\)."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "intro.html#definição-de-séries-temporais",
    "href": "intro.html#definição-de-séries-temporais",
    "title": "1  Introdução",
    "section": "1.1 Definição de séries temporais",
    "text": "1.1 Definição de séries temporais\nConsidere um fenômeno aleatório que será observado ao longo do tempo. A coleção de variáveis aleatórias indexadas no tempo associadas a este fenômeno será denominada série temporal. Neste caso, para cada instante de tempo \\(t\\), há uma variável \\(X(t)\\) associada.\n\n\n\nFigure 1 - Ilustração de uma série temporal\n\n\nAlguns autores definem séries temporais simplesmente como uma os valores de uma variável registrados ao longo do tempo. Essa definição não é útil para nós, uma vez que o tempo não necessariamente possui influência na variável, ou seja, é possível que a distribuição de \\(X(t)\\) não dependa de \\(t\\).\n\nImportante: estamos interessados apenas em séries temporais nas quais o modelo de probabilidades depende do tempo \\(t\\).\n\nA partir deste momento, \\(X(t)\\) será escrita como \\(X_t\\) e representará a variável aleatória associada ao tempo \\(t\\) e a versão minúscula \\(x_t\\) representará o valor observado."
  },
  {
    "objectID": "intro.html#a-função-de-autocorrelação",
    "href": "intro.html#a-função-de-autocorrelação",
    "title": "1  Introdução",
    "section": "1.3 A função de autocorrelação",
    "text": "1.3 A função de autocorrelação\nConsidere inicialmente uma amostra aleatória \\(X_1,\\ldots,X_n\\) (ou seja, todas as variáveis são independentes e possuem a mesma distribuição). Sejam \\[A_h=\\{X_1,\\ldots,X_{n-h}\\}\\] e \\[B_h=\\{X_h,\\ldots,X_n\\}.\\] Então, a correlação entre \\(A_h\\) e \\(B_h\\) é nula.\nDeste modo, um meio de verificar se a coleção observada é uma série temporal é observar a correlação amostral entre \\[a_h=\\{x_1,\\ldots,x_{n-h}\\}\\] e \\[b_h=\\{x_h,\\ldots,x_n\\},\\] para diferentes valores de \\(h\\).\nA função \\(r(h)\\) que representa a correlação amostral entre \\(a_h\\) e \\(b_h\\) é denominada autocorrelação. O valor \\(h\\) é denominado defasagem (do inglês, lag).\n\nPropriedades\n\n\\(r(0)=1\\)\n\\(-1\\leq r(h) \\leq 1\\)\n\n\n\nCorrelograma O gráfico \\((h,r(h))\\) é denominado correlograma, ou gráfico da função de autocorrelação."
  },
  {
    "objectID": "intro.html#lidando-com-séries-temporais-no-r",
    "href": "intro.html#lidando-com-séries-temporais-no-r",
    "title": "1  Introdução",
    "section": "1.2 Lidando com séries temporais no R",
    "text": "1.2 Lidando com séries temporais no R\nA tabela aabeixo apresenta o número de nascidos vivos por mês na cidade de Manaus em 2021.\n\n\n\nMês\nNo. nascidos vivos\n\n\n\n\nJaneiro\n3043\n\n\nFevereiro\n2902\n\n\nMarço\n3166\n\n\nAbril\n3014\n\n\nMaio\n3095\n\n\nJunho\n2955\n\n\nJulho\n3087\n\n\nAgosto\n3141\n\n\nSetembro\n3129\n\n\nOutubro\n3096\n\n\nNovembro\n3191\n\n\nDezembro\n3222\n\n\n\nPara todos os efeitos, uma série temporal é um vetor numérico.\n\nx &lt;- c(\n  3043, 2902, 3166, 3014,\n3095, 2955, 3087, 3141,\n3129, 3096, 3191, 3222\n\n)\n\nplot(x, type = 'l')\n\n\n\n\nContudo, é útil construir a série temporal como um objeto da classe ts. Tal função possui dois argumentos importantes:\n\nfrequency: representa o número de observações por unidade de tempo. Por exemplo, se o tempo está sendo registrado em anos, mas o dados são mensais, então frequency=12.\nstart: representa o momento que a série começa. Pode ser representado um único número ou por um vetor de dois números, com o segundo representando o momento dentro do período. Por exemplo start=c(1996,2) implica que a primeira observação data de fevereiro de 1996.\n\n\ny &lt;- ts( x, start = c(2021,1), frequency = 12)\ny\n\n      Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec\n2021 3043 2902 3166 3014 3095 2955 3087 3141 3129 3096 3191 3222\n\nts.plot(y)\n\n\n\n\nNo gráfico acima, a parte decimal no eixo \\(x\\) representa a fração do tempo entre de um ano (começando em 0 e acumulando 1/12 para cada mês subsequente).\nTambém podemos customizar o gráfico.\n\nplot(y, ylab = 'No. nascidos vivos mensal', lwd = 2, col = 'seagreen')\n\n\n\n\nA função window seleciona um subconjunto da série temporal. Abaixo selecionamos apenas os nascimentos entre Junho e Agosto e marcamos estes valores no gráfico.\n\nz &lt;- window(y, start=c(2021,6), end = c(2021,8))\n\nplot(y, ylab = 'No. nascidos vivos mensal', lwd = 2, col = 'seagreen')\nlines(z, col = 'brown', lwd= 2)\n\n\n\n\n\nExercício 1 Considere o total mensal de nascidos vivos na cidade de Manaus entre 2019 e 2020:\n\n\n\nAno\nMês\nNo. nascidos vivos\n\n\n\n\n2019\n1\n3.199\n\n\n\n2\n2.963\n\n\n\n3\n3.146\n\n\n\n4\n2.966\n\n\n\n5\n3.074\n\n\n\n6\n2.919\n\n\n\n7\n3.129\n\n\n\n8\n3.230\n\n\n\n9\n3.456\n\n\n\n10\n3.486\n\n\n\n11\n3.220\n\n\n\n12\n3.151\n\n\n2020\n1\n3.185\n\n\n\n2\n3.131\n\n\n\n3\n3.256\n\n\n\n4\n3.008\n\n\n\n5\n3.080\n\n\n\n6\n2.919\n\n\n\n7\n3.208\n\n\n\n8\n3.126\n\n\n\n9\n3.126\n\n\n\n10\n3.210\n\n\n\n11\n2.957\n\n\n\n12\n3.068\n\n\n\n\nConstrua um único vetor com os três anos apresentados\nA partir do vetor criado, construa um objeto do tipo ts\nFaça um gráfico da série.\nCrie um janela para ver apenas o ano de 2020.\nRepresente a janela acima no gráfico anterior.\n\n\n\nExercício 1"
  },
  {
    "objectID": "intro.html#a-classe-ts",
    "href": "intro.html#a-classe-ts",
    "title": "1  Introdução",
    "section": "1.2 A classe ts",
    "text": "1.2 A classe ts\nA tabela aabeixo apresenta o número de nascidos vivos por mês na cidade de Manaus em 2021.\n\n\n\nMês\nNo. nascidos vivos\n\n\n\n\nJaneiro\n3043\n\n\nFevereiro\n2902\n\n\nMarço\n3166\n\n\nAbril\n3014\n\n\nMaio\n3095\n\n\nJunho\n2955\n\n\nJulho\n3087\n\n\nAgosto\n3141\n\n\nSetembro\n3129\n\n\nOutubro\n3096\n\n\nNovembro\n3191\n\n\nDezembro\n3222\n\n\n\nPara todos os efeitos, uma série temporal é um vetor numérico.\n\nx &lt;- c(\n  3043, 2902, 3166, 3014,\n3095, 2955, 3087, 3141,\n3129, 3096, 3191, 3222\n\n)\n\nplot(x, type = 'l')\n\n\n\n\nContudo, é útil construir a série temporal como um objeto da classe ts. Tal função possui dois argumentos importantes:\n\nfrequency: representa o número de observações por unidade de tempo. Por exemplo, se o tempo está sendo registrado em anos, mas o dados são mensais, então frequency=12.\nstart: representa o momento que a série começa. Pode ser representado um único número ou por um vetor de dois números, com o segundo representando o momento dentro do período. Por exemplo start=c(1996,2) implica que a primeira observação data de fevereiro de 1996.\n\n\ny &lt;- ts( x, start = c(2021,1), frequency = 12)\ny\n\n      Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec\n2021 3043 2902 3166 3014 3095 2955 3087 3141 3129 3096 3191 3222\n\nts.plot(y)\n\n\n\n\nNo gráfico acima, a parte decimal no eixo \\(x\\) representa a fração do tempo entre de um ano (começando em 0 e acumulando 1/12 para cada mês subsequente).\nTambém podemos customizar o gráfico.\n\nplot(y, ylab = 'No. nascidos vivos mensal', lwd = 2, col = 'seagreen')\n\n\n\n\nA função window seleciona um subconjunto da série temporal. Abaixo selecionamos apenas os nascimentos entre Junho e Agosto e marcamos estes valores no gráfico.\n\nz &lt;- window(y, start=c(2021,6), end = c(2021,8))\n\nplot(y, ylab = 'No. nascidos vivos mensal', lwd = 2, col = 'seagreen')\nlines(z, col = 'brown', lwd= 2)\n\n\n\n\n\nExercício 1 Considere o total mensal de nascidos vivos na cidade de Manaus entre 2019 e 2020:\n\n\n\nAno\nMês\nNo. nascidos vivos\n\n\n\n\n2019\n1\n3.199\n\n\n\n2\n2.963\n\n\n\n3\n3.146\n\n\n\n4\n2.966\n\n\n\n5\n3.074\n\n\n\n6\n2.919\n\n\n\n7\n3.129\n\n\n\n8\n3.230\n\n\n\n9\n3.456\n\n\n\n10\n3.486\n\n\n\n11\n3.220\n\n\n\n12\n3.151\n\n\n2020\n1\n3.185\n\n\n\n2\n3.131\n\n\n\n3\n3.256\n\n\n\n4\n3.008\n\n\n\n5\n3.080\n\n\n\n6\n2.919\n\n\n\n7\n3.208\n\n\n\n8\n3.126\n\n\n\n9\n3.126\n\n\n\n10\n3.210\n\n\n\n11\n2.957\n\n\n\n12\n3.068\n\n\n\n\nConstrua um único vetor com os três anos apresentados\nA partir do vetor criado, construa um objeto do tipo ts\nFaça um gráfico da série.\nCrie um janela para ver apenas o ano de 2020.\nRepresente a janela acima no gráfico anterior."
  },
  {
    "objectID": "intro.html#o-pacote-lubridate",
    "href": "intro.html#o-pacote-lubridate",
    "title": "1  Introdução",
    "section": "1.3 O pacote lubridate",
    "text": "1.3 O pacote lubridate\n\nExercício 1"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MLD",
    "section": "",
    "text": "Prefácio"
  },
  {
    "objectID": "acf.html",
    "href": "acf.html",
    "title": "3  A função de autocorrelação",
    "section": "",
    "text": "Considere inicialmente uma amostra aleatória \\(X_1,\\ldots,X_n\\) (ou seja, todas as variáveis são independentes e possuem a mesma distribuição). Sejam \\[A_h=\\{X_1,\\ldots,X_{n-h}\\}\\] e \\[B_h=\\{X_h,\\ldots,X_n\\}.\\] Então, a correlação entre \\(A_h\\) e \\(B_h\\) é nula.\nDeste modo, um meio de verificar se a coleção observada é uma série temporal é observar a correlação amostral entre \\[a_h=\\{x_1,\\ldots,x_{n-h}\\}\\] e \\[b_h=\\{x_h,\\ldots,x_n\\},\\] para diferentes valores de \\(h\\).\nA função \\(r(h)\\) que representa a correlação amostral entre \\(a_h\\) e \\(b_h\\) é denominada autocorrelação. O valor \\(h\\) é denominado defasagem (do inglês, lag).\n\nPropriedades\n\n\\(r(0)=1\\)\n\\(-1\\leq r(h) \\leq 1\\)\n\n\n\nCorrelograma O gráfico \\((h,r(h))\\) é denominado correlograma, ou gráfico da função de autocorrelação."
  },
  {
    "objectID": "intro.html#o-pacote-data.table",
    "href": "intro.html#o-pacote-data.table",
    "title": "1  Introdução",
    "section": "1.3 O pacote data.table",
    "text": "1.3 O pacote data.table\nAssim como números e textos possuem classes específicas, as datas no ambiente R também possuem sua Date.\n\n# 3 de agosto de 1998 (formato americano)\nx &lt;- '1998/8/3'\nas.Date(x)\n\n[1] \"1998-08-03\"\n\n\nPara que o R entenda uma data no formato nacional, é necessário mudar o formato:\n\n# 3 de agosto de 1998 (formato nacional)\nx &lt;- '3/8/1998'\nas.Date(x, format = '%d/%m/%Y')\n\n[1] \"1998-08-03\"\n\n\nLidamos com datas quando temos uma fonte de dados bruta, mas em geral nosso objetivo é determinar a quantidade de eventos dentro de dias, semanas, meses ou anos. O pacote data.table permite lidar com esse problema de modo rápido. Podemos criar um objeto deste tipo utilizando a função fread. A seguir, vamos baixar uma base de dados de acidentes com aeronaves, mantida pela Força Aérea Brasileira e transformar a data de formato nacional para a classe Date.\n\nlibrary(data.table)\nurl &lt;- 'https://drive.google.com/uc?authuser=0&id=1iYrnwXgmLK07x8b330aD73scOVruZEuz&export=download'\n\naereo &lt;-  fread(url, encoding = 'Latin-1')\naereo$ocorrencia_dia &lt;- as.Date(aereo$ocorrencia_dia, '%d/%m/%Y')\n\nUm objeto do tipo data.table permite uma série de consultas. Em geral, pode-se fazer aereo[a,b,c], onde a é uma consulta/função nas linhas, b nas colunas e c é um agrupador. Uma excelente introdução pode ser vista em Introduction to data.table.\nAbaixo, selecionamos apenas a coluna de interesse.\n\nfab_dia &lt;- aereo[,'ocorrencia_dia',]\nhead(fab_dia)\n\n   ocorrencia_dia\n1:     2023-04-05\n2:     2023-06-24\n3:     2023-06-27\n4:     2023-06-30\n5:     2023-06-25\n6:     2023-06-23\n\n\nAo utilizar o operador .N em [,.N,c], é retornado o número de linhas que possuem o agrupamento em c. Vamos agrupar as datas do nosso banco por ano.\n\nfab_ano &lt;- fab_dia[, .N, by=.(year(ocorrencia_dia))]\nfab_ano &lt;-fab_ano[ order(year) ]\nhead(fab_ano)\n\n   year   N\n1: 2013 654\n2: 2014 569\n3: 2015 471\n4: 2016 403\n5: 2017 432\n6: 2018 444\n\n\nAgora, podemos fazer o gráfico da série\n\nfab_ano &lt;- ts( fab_ano, start = 2013)\nplot(fab_ano[,2], lwd = 2, ylab = 'No. acidentes/ano', xlab = 'Ano')\n\n\n\n\nTambém podemos fazer uma série mensal:\n\nfab_mes &lt;- fab_dia[, .N, by=.(year(ocorrencia_dia), month(ocorrencia_dia))]\n\nfab_mes &lt;-fab_mes[ order(year, month ) ]\nhead(fab_mes)\n\n   year month  N\n1: 2013     1 58\n2: 2013     2 60\n3: 2013     3 64\n4: 2013     4 60\n5: 2013     5 60\n6: 2013     6 49\n\n\nO gráfico dessa nova série é:\n\nfab_mes &lt;- ts( fab_mes[,3], start = c(2013, 1), frequency = 12)\nplot(fab_mes, lwd = 2, ylab = 'No. acidentes/mês', xlab = 'Ano')\n\n\n\n\n\nExercício 1\nA série abaixo contém a data dos óbitos maternos no Brasil a partir de 2010.\n\nurl &lt;- 'https://drive.google.com/uc?authuser=0&id=1tYFFT9L2iopKmBDUI3P8qNIRaOnMYj7d&export=download'\n\nCrie uma série temporal com o número de óbitos mensal e faça um gráfico. Crie uma janela para colocar no gráfico o período da pandemia de COVID-19."
  },
  {
    "objectID": "sinal.html",
    "href": "sinal.html",
    "title": "2  Tipos de sinal",
    "section": "",
    "text": "Em geral, a série temporal possui componentes de dois tipos: sinal e ruído. O primeiro é uma função do tempo geralmente relacionado com a média da série, enquanto que o segundo está relacionado com a variância. Podemos assumir que essa relação é aditiva:\n\\[X_t=\\hbox{sinal}(t)+\\varepsilon_t\\] onde \\(\\varepsilon_t\\) é o ruído. Em alguns casos essa relação é multiplicativa, ou seja,\n\\[X_t=\\exp\\{\\hbox{sinal}(t)+\\varepsilon_t\\},\\] e, nesses casos, aplicamos o logaritmo na série para que as componentes se tornem aditivas.\nOs sinais mais importantes são:\n\nTendência: um comportamento de subida ou descida que pode ser observado no médio/longo prazo\nSazonalidade: são componentes que surgem sistematicamente ao longo do tempo, como por exemplo: flutuações de temperatura entre estações, início e fim do semestre letivo, Natal, dias úteis, feriados flutuantes como a Páscoa e o Carnaval.\n\nO ruídos mais importantes são:\n\nBranco: possuem variância constante e não correlacionados.\nMédia móvel de ordem \\(q\\): possuem variância constante e são correlacionados com até \\(q\\) ruídos anteriores.\n\nA série a seguir representa o número de vendas de passagens aéreas nos EUA. Note o comportamento da tendência e da sazonalidade.\n\nplot(AirPassengers)"
  },
  {
    "objectID": "acf.html#o-correlograma-de-uma-amostra-aleatória",
    "href": "acf.html#o-correlograma-de-uma-amostra-aleatória",
    "title": "3  A função de autocorrelação",
    "section": "3.1 O correlograma de uma amostra aleatória",
    "text": "3.1 O correlograma de uma amostra aleatória\nQuando a amostra é aleatória, a função de autocorrelação é nula para qualquer defasagem diferente de 0. Deste modo, o correlograma deve apresentar valores próximos de zero.\nPara entender o que próximo de zero significa, o limites do intervalo de confiança para o coeficiente de correlação sobre a hipótese de que esta é nula são colocados no gráfico.\nAbaixo ilustramos um correlograma para uma amostra de variáveis aleatórias independentes com distribuição normal padrão.\n\nx &lt;- rnorm(120)\n\n# correlograma\nacf(x)\n\n\n\n# o mesmo correlograma com uma defasagem maior\nacf(x, lag = 50)"
  },
  {
    "objectID": "acf.html#o-correlograma-com-a-componente-de-tendência",
    "href": "acf.html#o-correlograma-com-a-componente-de-tendência",
    "title": "3  A função de autocorrelação",
    "section": "3.2 O correlograma com a componente de tendência",
    "text": "3.2 O correlograma com a componente de tendência\nQuando uma série exibe tendência, o correlograma exibe um descaimento lento e persistente.\nConsidere, por exemplo, a série\n\\[x_t= t + \\varepsilon_t,\\] onde \\(\\varepsilon_t\\sim\\hbox{Normal}(0,5^2)\\). Abaixo simulamos essa série e apresentamos o respectivo correlograma\n\nx &lt;- rnorm(100, 1:100, 5)\n\noo &lt;- par( mfrow=c(1,2))\nts.plot(x)\nacf(x, lag = 50)\n\n\n\npar(oo)\n\nObserve as similaridades do correlograma acima com o observado para a série de acidentes aéreos mensais vista anteriormente.\n\noo &lt;- par( mfrow=c(1,2))\nts.plot( fab_mes , ylab = 'No. acidentes aéreos mensal' )\nacf(fab_mes , lag = 50,  main ='correlograma')\n\n\n\npar(oo)"
  },
  {
    "objectID": "acf.html#o-correlograma-com-a-componente-de-sazonalidade",
    "href": "acf.html#o-correlograma-com-a-componente-de-sazonalidade",
    "title": "3  A função de autocorrelação",
    "section": "3.3 O correlograma com a componente de sazonalidade",
    "text": "3.3 O correlograma com a componente de sazonalidade\nO sinal sazonal é caracterizado por um comportamento periódico. Existem dois comportamentos sazonais típicos. O primeiro é baseado na função harmônica:\n\\[\\hbox{sinal}(t)=A\\left(\\frac{2\\pi}{p}t + \\phi\\right)\\] Neste tipo de sinal, há um comportamento em forma de onda já estabelecido. Eis algumas informações importantes:\n\nO valor \\(p\\), denominado período, equivale ao tempo que demora para o padrão se repetir.\n\\(A\\) é denominado amplitude e representa o maior/menor valor que este sinal pode aingir.\nPor último, \\(\\phi\\) é denominado fase, e serve basicamente para deslocar a onda.\n\nAbaixo seguem alguns exemplos de harmônicos, todos com período 12:\n\noo &lt;- par( cex = 1.3)\ncurve( sin( x* 2*pi/12), 0,24, lwd = 2, ylab = expression( sin( 2*pi*t/12 )))\nabline(h = 0, lty = 2 )\nabline(v=12, lty = 2)\n\n\n\ncurve( .5*sin( x* 2*pi/12), 0,24, lwd = 2, ylab = expression( .5*sin( 2*pi*t/12 )), ylim = c(-1,1))\nabline(h = 0, lty = 2 )\nabline(v=12, lty = 2)\n\n\n\ncurve( sin( x* 2*pi/12+90), 0,24, lwd = 2, ylab = expression( sin( 2*pi*t/12 +90)), ylim = c(-1,1))\nabline(h = 0, lty = 2 )\nabline(v=12, lty = 2)\n\n\n\n\n\nx &lt;- sin( 2*pi/12 * 1:100) + rnorm(100,0,.1)\nts.plot(x)\n\n\n\nx &lt;- c()\nx[1:12] &lt;- rnorm(12,0,.1)\nfor(i in 13:100) x[i] &lt;- .8*x[i-12] + rnorm(1,0,.1)\nts.plot(x)"
  },
  {
    "objectID": "acf.html#o-correlograma-com-a-componente-de-sazonalidade---sinal-harmônico",
    "href": "acf.html#o-correlograma-com-a-componente-de-sazonalidade---sinal-harmônico",
    "title": "3  A função de autocorrelação",
    "section": "3.3 O correlograma com a componente de sazonalidade - sinal harmônico",
    "text": "3.3 O correlograma com a componente de sazonalidade - sinal harmônico\nO sinal sazonal é caracterizado por um comportamento periódico. Existem dois comportamentos sazonais típicos. O primeiro é baseado na função harmônica:\n\\[\\hbox{sinal}(t)=A\\cos\\left(\\frac{2\\pi}{p}t + \\phi\\right)\\] Neste tipo de sinal, há um comportamento em forma de onda já estabelecido. Eis algumas informações importantes:\n\nO valor \\(p\\), denominado período, equivale ao tempo que demora para o padrão se repetir.\n\\(A\\) é denominado amplitude e representa o maior/menor valor que este sinal pode aingir.\nPor último, \\(\\phi\\) é denominado fase, e serve basicamente para deslocar a onda.\n\nAbaixo seguem alguns exemplos de harmônicos, todos com período 12:\n\noo &lt;- par( cex = 1.3)\ncurve( cos( x* 2*pi/12), 0,24, lwd = 2, ylab = expression( cos( 2*pi*t/12 )))\nabline(h = 0, lty = 2 )\nabline(v=12, lty = 2)\n\n\n\ncurve( .5*cos( x* 2*pi/12), 0,24, lwd = 2, ylab = expression( .5*cos( 2*pi*t/12 )), ylim = c(-1,1))\nabline(h = 0, lty = 2 )\nabline(v=12, lty = 2)\n\n\n\ncurve( cos( x* 2*pi/12+90), 0,24, lwd = 2, ylab = expression( cos( 2*pi*t/12 +90)), ylim = c(-1,1))\nabline(h = 0, lty = 2 )\nabline(v=12, lty = 2)\n\n\n\n\nAbaixo simulamos uma série temporal com um sinal do tipo harmônico. Observe que o comportamento em forma de onda é aparente na função de autocorrelação.\n\nx &lt;- cos( 2*pi/12 * 1:100) + rnorm(100,0,.1)\n\noo &lt;- par( mfrow = c(1,2))\nts.plot(x)\nacf(x)\n\n\n\npar(oo)\n\nAbaixo, apresentamos a temperatura mensal observada no Castelo de Nottingham, entre 1920-1939. Compare os resultados com os gráficos acima.\n\noo &lt;- par( mfrow = c(1,2))\n  plot(nottem)\n  acf(nottem)\n\n\n\npar(oo)"
  },
  {
    "objectID": "acf.html#o-correlograma-com-a-componente-de-sazonalidade---sinal-autorregressivo",
    "href": "acf.html#o-correlograma-com-a-componente-de-sazonalidade---sinal-autorregressivo",
    "title": "3  A função de autocorrelação",
    "section": "3.4 O correlograma com a componente de sazonalidade - sinal autorregressivo",
    "text": "3.4 O correlograma com a componente de sazonalidade - sinal autorregressivo\nNesse tipo de sazonalidade, ainda há um período \\(p\\), mas não há um sinal harmônico. O valor da série no tempo \\(t\\) é baseado no valor observado no tempo \\(t-p\\).\nQuando a sazonalidade possue essa característica, há uma autocorrelação marcante nos múltiplos de \\(p\\). Observe a série simulada abaixo, com um período \\(p=12\\)\n\nset.seed(123)\noo &lt;- par( mfrow = c(1,2))\nx &lt;- rnorm(12,0,.1)\nfor(i in 13:100) x[i] &lt;- .6*x[i-12] + rnorm(1,0,.05)\nts.plot(x)\nacf(x, lag = 50)\n\n\n\npar(oo)"
  },
  {
    "objectID": "acf.html#exercícios",
    "href": "acf.html#exercícios",
    "title": "3  A função de autocorrelação",
    "section": "3.5 Exercícios",
    "text": "3.5 Exercícios\n\nExercício 1 Estude o comportamento da série ldeaths, que conta o número mensal de óbitos por doenças pulmonares no Reino Unido.\n\n\nExercício 2 Estude o comportamento da série do número de óbitos maternos mensais.\n\n\nExercício 3 Em 2017, um epidemiologista estava interessado na série de suicídios no Mato Grosso do Sul. O banco de dados utilizado é dado a seguir. Construa uma série mensal e estude seu comportamento\n\nurl &lt;- 'https://drive.google.com/uc?authuser=0&id=1DMSgrQDl0636Lw0Y0MYJHJrgw_2uXntM&export=download'"
  },
  {
    "objectID": "ferramentas.html#estudo-da-tendência-utilizando-o-loess",
    "href": "ferramentas.html#estudo-da-tendência-utilizando-o-loess",
    "title": "4  Mais ferramentas exploratórias",
    "section": "4.1 Estudo da tendência utilizando o loess",
    "text": "4.1 Estudo da tendência utilizando o loess\nLoes é um modelo de regressão não linear não paramétrico. Abaixo mostramos como utilizá-lo considerando um banco de dados com diversas marcas de veículos e a relação entre a variável milhas por galão (mpg) e deslocamento (disp)\n\nplot( mtcars$disp, mtcars$mpg )\nlw &lt;- loess( mpg ~ disp, data = mtcars )\npoints(mtcars$disp, lw$fitted, col = 'tomato', lwd = 2)\nlegend('topright', c('Observado','Ajustado'),fill=c(1,'tomato'), bty='n')\n\n\n\n\nPodemos estimar a tendência utilizando o loess, imaginando uma regressão do tipo:\n\\[E(X_t)=g(t),\\] ou seja, utilizando o tempo como regressora. Vamos ilustrar a ideia utilizando a série de acidentes aéreos mensais da FAB.\n\n# criando a variável regressora\ntempo &lt;- 1 : length(fab_mes)\n\n# aplicando o loess\nlw &lt;- loess( fab_mes ~ tempo)\n\n# transformando o valor predito em uma série temporal\n\nfit &lt;- ts(lw$fitted, start = start(fab_mes), frequency = frequency(fab_mes) )\n\n# gráfico da tendência estimada\n\nts.plot( fab_mes, ylab = 'No. acidentes/mês' , lwd = 2)\nlines(fit, lwd = 2, col = 'tomato')\nlegend('bottomright', c('Observado','Ajustado'),fill=c(1,'tomato'), bty='n')\n\n\n\n\nAcima estimamos a tendência. Denomine este sinal estimado por \\(\\hat{g}(t)\\). Agora, considere a série\n\\[y_t=x_t-\\hat{g}(t).\\] Ao analisar esta série, duas coisas podem acontecer:\n\nVamos encontrar um comportamento semelhante a um ruído (correlograma com barras praticamente nulas)\nVamos encontrar algum outro sinal ainda não ajustado.\n\nOs gráficos abaixo mostram que não há mais sinais para procurar\n\nyt &lt;- fab_mes - fit\n\nts.plot(yt)\n\n\n\nacf(yt, lag = 30)\n\n\n\n\nPortanto, esta série pode ser escrita como\n\\[x_t = \\hbox{tendência}_t+\\varepsilon_t,\\] onde \\(\\varepsilon_t\\) é um ruído branco.\nAbaixo, vamos analisar a série de taxa de desemprego mensal, entre março de 2002 e dezembro de 2015.\n\nurl &lt;- 'https://www.dropbox.com/s/rmgymzsic99qawd/desemprego.csv?dl=1'\n\nbanco &lt;- fread(url)\n\ndesemprego&lt;- ts( banco[,'V2',], start = c(2002,3), frequency=12)\n\nts.plot(desemprego, ylab = 'Taxa de desemprego')\n\n\n\nacf(desemprego, lag = 30)\n\n\n\n\nÉ possível verificar que há tendência e sazonalidade na série. Vamos estimar a componente de tendência primeiro.\n\n# criando a variável regressora\ntempo &lt;- 1 : length(desemprego)\n\n# aplicando o loess\nlw &lt;- loess( desemprego ~ tempo)\n\n# transformando o valor predito em uma série temporal\n\nfit &lt;- ts(lw$fitted, start = start(desemprego), frequency = frequency(desemprego) )\n\n# gráfico da tendência estimada\n\nts.plot( desemprego, ylab = 'Taxa de desemprego' , lwd = 2)\nlines(fit, lwd = 2, col = 'tomato')\nlegend('topright', c('Observado','Ajustado'),fill=c(1,'tomato'), bty='n')\n\n\n\n\nVamos eliminar a tendência estiamada e avaliar o restante.\n\nyt &lt;- desemprego - fit\n\nts.plot(yt)\n\n\n\nacf(yt, lag = 50)\n\n\n\n\nFica claro o comportamento sazonal. Note que o período não parece ser anual, mas sim de 3 em 3 anos. Vamos avaliar esse aspecto com mais detalhes na próxima seção.\n\n4.1.1 Exercícios\n\nExercício 1 Considerando o banco de dados sobre suicídios no Mato Grosso do Sul:\n\nEstime a tendência\nRemova a tendência estimada e verifique se o resultado é um ruído branco\n\n\n\nExercício 2 Verifique se há tendência na série ldeaths.\n\n\nExercício 3 Verifique se há tendência na série de óbitos maternos, cuja url é\n\nurl &lt;- 'https://drive.google.com/uc?authuser=0&id=1tYFFT9L2iopKmBDUI3P8qNIRaOnMYj7d&export=download'\n\nFaça duas análises, uma com a série inteira e outra eliminando os dados a partir de 2020.\n\n\nExercício 4. O banco de dados abaixo apresenta algumas séries temporais mensais com o número de nascidos vivos em Manaus\n\nurl &lt;- 'https://drive.google.com/uc?authuser=0&id=139h6x2g7PkAHNTzsbQKUl5G2MqoXYk6Y&export=download'\n\n\nEstime a tendência dos nascimentos considerando duas séries: partos vaginais e cesários. Coloque as duas informações no mesmo gráfico.\nElimine a tendência de cada série e verifique se há outro sinal a ser estimado.\n\n\n\nExercício 1"
  },
  {
    "objectID": "ferramentas.html#o-periodograma",
    "href": "ferramentas.html#o-periodograma",
    "title": "4  Mais ferramentas exploratórias",
    "section": "4.2 O periodograma",
    "text": "4.2 O periodograma\n\n4.2.1 Introdução\nTodo padrão sazonal possui um período - a quantidade de tempo necessária para que o padrão se repita. O inverso desse período é denominado frequência fundamental, que é a fração de um ciclo por unidade de tempo.\n\nExemplo: Considere o período de 12 meses. Então, a frequência fundamental é 1/12 (ou seja, cada mês representa um doze ávos do período de 1 ano).\n\nLembremos que o sinal harmônico é igual a \\[\\hbox{sinal}(t)=A\\sin\\left(2\\pi\\omega t+\\phi\\right),\\] onde \\(\\omega=1/p\\) é a frequência. Com um pouco de trigonometria, podemos mostrar que\n\\[\\hbox{sinal}(t)=\\beta_1\\cos\\left(2\\pi\\omega t\\right)+ \\beta_2\\sin\\left(2\\pi\\omega t\\right)\\] onde \\(\\beta_1=A\\cos(\\phi)\\) e \\(\\beta_2=-A\\sin(\\phi)\\). É possível mostrar também que \\(A=\\sqrt{\\beta_1+\\beta_2}\\) e \\(\\phi=\\cos^{-1}(\\beta_1/A)\\). A vantagem dessa nova forma é que o sinal pode ser escrito como um modelo linear e pode ser estimado facilmente. A soma de quadrados explicada pela regressão é proporcional à\n\\[I(\\omega)=\\hat{A}(\\omega)^2 \\] e podemos mostrar que a estimativa de máxima verossimilhança para \\(\\omega\\) é o valor que maximiza \\(I(\\omega)\\).\n\nPeriodograma O gráfico de \\(I(\\omega)\\) é denominado periodograma.\n\nVamos criar a função periodograma\n\nIw &lt;- function(y,w){\n\n  # matriz de planetamento\n  n &lt;- length(y)\n  t &lt;- 1:n\n  x &lt;- cbind(cos(2*pi*w*t), sin(2*pi*w*t))\n  \n  # coeficientes do modelo linear\n  beta &lt;- coefficients(lm(y ~x-1))\n  \n  # amplitude\n  A &lt;- sqrt(sum(beta^2))\n  \n  # Iw\n  .5*n*A^2\n}\n\nperiodograma &lt;- function(y){\n  # gráfico\n  n &lt;- length(y)\n  w_detec &lt;- ( 1 : floor(  (n-1)/ 2) ) / n\n  I_w &lt;- sapply( w_detec, function(w) Iw(y , w) )\n  plot( 1 / w_detec , I_w, xlab = 'Período', ylab =     expression(I(w)), type = 'h' , lwd = 2)\n  \n  # encontrando o periodo\n  fund &lt;-  w_detec[ which( I_w == max(I_w))]\n  cat('Período: ',1/fund,'\\n')\n\n}\n\nNa função acima y é a série temporal. Vamos aplicar essa função para a série de temperaturas no Castelo de Nottingham.\n\nperiodograma(nottem)\n\n\n\n\nPeríodo:  12 \n\n\n\n\n4.2.2 Periodograma para amostras aleatórias\nÉ importante notar que a frequência fundamental é um pico expressivo em relação aos demais. Abaixo mostramos o periodograma para uma amostra aleatória - note como há vários picos, evidenciando a falta de uma frequência fundamental.\n\nperiodograma(rnorm(100))\n\n\n\n\nPeríodo:  7.692308 \n\n\n\n\n4.2.3 Periodograma na presença de tendência\nÉ importante remover a tendência antes de aplicar o periodo. Por exemplo, considere novamente a série AirPassengers\n\nts.plot(AirPassengers)\n\n\n\nperiodograma(AirPassengers)\n\n\n\n\nPeríodo:  144 \n\n\nEmbor exista uma sazonalidade clara, o periodograma retorna um período de 12 anos, algo irreal. Vamos remover a tendência.\n\n# criando o loess\ny &lt;- AirPassengers\ntempo &lt;- 1:length(y)\nlw &lt;- loess( y ~ tempo )\nfit &lt;- lw$fitted\n\n# criando a série livre de tendência\ny_detrend &lt;- ts( y-fit, start = start(y), frequency = frequency(y))\n\nts.plot( y_detrend )\n\n\n\nperiodograma( y_detrend )\n\n\n\n\nPeríodo:  12 \n\n\n\n\n4.2.4 Exercícios\n\nExercício 1. Determine o período da série ldeaths - número de óbito mensais por doenças pulmonares no Reino Unido.\n\n\nExercício 2. Determine o período da série de óbitos maternos, cuja url é:\n\nurl &lt;- 'https://drive.google.com/uc?authuser=0&id=1tYFFT9L2iopKmBDUI3P8qNIRaOnMYj7d&export=download'\n\n\n\nExercício 3. A série co2 representa a concentração de CO\\(_2\\) na atmosfera medida em Mauna Loa. Analise a tendência da série e estime o período.\n\n\nExercício 4. Determine a tendência e o período da série mensal do número de nascidos vivos em Manaus, independente do tipo de parto."
  },
  {
    "objectID": "ferramentas.html#exercícios",
    "href": "ferramentas.html#exercícios",
    "title": "4  Mais ferramentas exploratórias",
    "section": "4.2 Exercícios",
    "text": "4.2 Exercícios\n\nExercício 1 Considerando o banco de dados sobre suicídios no Mato Grosso do Sul:\n\nEstime a tendência\nRemova a tendência estimada e verifique se o resultado é um ruído branco\n\n\n\nExercício 2 Verifique se há tendência na série ldeaths.\n\n\nExercício 3 Verifique se há tendência na série de óbitos maternos, cuja url é\n\nurl &lt;- 'https://drive.google.com/uc?authuser=0&id=1tYFFT9L2iopKmBDUI3P8qNIRaOnMYj7d&export=download'\n\nFaça duas análises, uma com a série inteira e outra eliminando os dados a partir de 2020.\n\n\nExercício 4. O banco de dados abaixo apresenta algumas séries temporais mensais com o número de nascidos vivos em Manaus\n\nurl &lt;- 'https://drive.google.com/uc?authuser=0&id=139h6x2g7PkAHNTzsbQKUl5G2MqoXYk6Y&export=download'\n\n\nEstime a tendência dos nascimentos considerando duas séries: partos vaginais e cesários. Coloque as duas informações no mesmo gráfico.\nElimine a tendência de cada série e verifique se há outro sinal a ser estimado.\n\n\n\nExercício 1"
  },
  {
    "objectID": "ferramentas.html#o",
    "href": "ferramentas.html#o",
    "title": "4  Mais ferramentas exploratórias",
    "section": "4.4 O",
    "text": "4.4 O"
  },
  {
    "objectID": "ferramentas.html#ajuste-por-fatores-sazonais",
    "href": "ferramentas.html#ajuste-por-fatores-sazonais",
    "title": "4  Mais ferramentas exploratórias",
    "section": "4.3 Ajuste por fatores sazonais",
    "text": "4.3 Ajuste por fatores sazonais\nConsidere novamente o harmônico\n\\[\\hbox{sinal}(t)=A\\cos\\left(\\frac{2\\pi}{p}t+\\phi\\right)\\]\nO sinal no tempo \\(t=1+p\\) é equivalente ao sinal no tempo 1:\n\\[\\hbox{sinal}(1+p)=A\\cos\\left(\\frac{2\\pi}{p}+2\\pi+\\phi\\right)=A\\cos\\left(\\frac{2\\pi}{p}+\\phi\\right)=\\hbox{sinal}(1)\\]\nIsso é verdade para todo \\(t=1+kp\\), onde \\(k=1,2,\\ldots.\\) Isto implica que, na prática, a imagem de \\(\\hbox{sinal}(t)\\) só pode ser \\(p\\) valores:\n\\[\\hbox{sinal}(t)=\\left\\{\\begin{array}{ll}\\hbox{sinal}(1),&t=1,1+p,1+2p,\\ldots,\\\\\n\\hbox{sinal}(2),&t=2,2+p,2+2p\\ldots,\\\\\n\\vdots,&\\vdots\\\\\n\\hbox{sinal}(p),&t=p,2p,3p\\ldots,\\end{array}\\right.\\]\nEntão \\[x_t=\\hbox{sinal}(t)+\\varepsilon_t\\] pode ser considerado uma ANOVA com um fator.\nConsidere a série ldeths, que já sabemos ter uma leve tendência decrescente e sazonalidade com período 12. Primeiro, vamos encontrar a série livre de tendência:\n\ntempo &lt;- 1:length(ldeaths)\nlw &lt;- loess( ldeaths ~ tempo)\ntend &lt;- lw$fitted\n\ntend &lt;- ts( tend, start = start(ldeaths), frequency = frequency(ldeaths))\n\n#  série sem tendência\nd_ldeaths &lt;- ldeaths - tend\n\nEm seguida, encontramos o período.\n\nperiodograma(d_ldeaths)\n\n\n\n\nPeríodo:  12 \n\n\nNesse momento, devemos atribuir o período para o objeto ts, fazendo\n\nd_ldeaths &lt;- ts( d_ldeaths, frequency= 12) \n\nNote que o código acima foi inócuo porque o objeto ldeaths já tinha o período 12.\nAntes de fazer o ajuste sazonal, é possível fazer um gráfico com doze séries temporais, uma para cada fator sazonal (no nosso exemplo, uma série só de janeiros, de fevereiros, etc). Mostramos isso a seguir:\n\nmonthplot(d_ldeaths)\n\n\n\n\nNo gráfico acima, a linha horizontal em cada mês representa a média.\nAgora, vamos estimar os 12 fatores sazonais. Para isso, vamos utilizar a função cycle, que mostra a posição de cada observação dentro do ciclo sazonal. Eis um exemplo de seu funcionamento:\n\nhead(cycle(d_ldeaths), 14)\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12  1  2\n\n\nVamos transformar o resultado do cycle em um fator e ajustar uma ANOVA:\n\nciclo &lt;- as.factor(cycle(d_ldeaths))\nmod &lt;- lm( d_ldeaths ~ciclo-1)\n\nplot(coefficients(mod))\n\n\n\n\nPor último, vamos dessazonalizar a série:\n\nsaz_fit &lt;- mod$fitted.values\nresiduo &lt;- d_ldeaths - saz_fit\n\nplot(residuo)\n\n\n\nacf(residuo, lag = 30)\n\n\n\n\n\n4.3.1 Exercícios\n\nExercício 1\nSepare os sinais dos ruídos nas seguintes séries temporais:\n\n1. `nottem`\n2. Óbitos maternos\n3. Número de nascidos vivos\n4. Taxa de desemprego\n5. `AirPassangers`"
  },
  {
    "objectID": "mld.html#inferência-bayesiana",
    "href": "mld.html#inferência-bayesiana",
    "title": "5  O modelo linear dinâmico",
    "section": "5.1 Inferência bayesiana",
    "text": "5.1 Inferência bayesiana\n\nTab1Tab2\n\n\nAqui não tem nada. Mas você deve pensar nos pontos verdes e vermelhos.\n\n\n\n\n\n\n\n\n\n\nVamos supor que as possíveis probabilidades do ponto ser vermelho são\n\\[\\Theta=\\{.1,.2,.3,.4,.5,.6,.7,.8,.9\\}\\]\nConsidere uma amostra de tamanho 30. Vamos supor que o número de pontos vermelhos tem distribuição Binomial(30, \\(\\theta\\)).\n\n\n\nPriori\n\n\n\n\n\nTotal de sucessos:"
  },
  {
    "objectID": "mld.html#o-modelo-linear-dinâmico",
    "href": "mld.html#o-modelo-linear-dinâmico",
    "title": "5  O modelo linear dinâmico",
    "section": "5.1 O modelo linear dinâmico",
    "text": "5.1 O modelo linear dinâmico\nSeja \\(y_1,\\ldots,t\\) uma série temporal. Seja \\(D_j={y_1,\\ldots,y_j}\\). Dizemos que \\(y_t\\) é um modelo linear dinâmico se\n\\[\\begin{align}\ny_t|\\boldsymbol{\\theta}_t,D_{t-1}&\\sim\\hbox{Normal}(\\boldsymbol{F}_t'\\boldsymbol{\\theta}_t,V_t)\\\\\n\\boldsymbol{\\theta}_t|\\boldsymbol{\\theta}_{t-1},D_{t-1}&\\sim\\hbox{Normal}(\\boldsymbol{G}_t\\boldsymbol{\\theta}_{t-1},\\boldsymbol{W}_t)\n\\end{align}\\]\nA expressão acima, os \\(\\theta\\)’s são denominados estados. Para a completa especificação do modelo, devemos informar valores iniciais \\(m_0\\) e \\(C_0\\) que representam nossa opinião sobre os estados antes do tempo \\(1\\):\n\\[\\theta_0\\sim\\ N(m_0,C_0)\\] Escolhas diferentes para \\(\\boldsymbol{F}_t\\) e \\(\\boldsymbol{G}_t\\) permitem acomodar sinais diferentes.\nPode-se mostrar que \\(y_{t+h}|D_t\\) tem distribuição normal. Como \\(t+h\\) é um tempo não observado, essa é a distribuição para previsões. Neste caso, a função de previsão para o horizonte \\(h\\) é\n\\[f_t(h)=E(Y_{t+h}|D_{t})\\] onde \\(E(.)\\) sempre deve ser lido como média.\nO pacote para lidar com modelos lineares dinâmicos é o dlm. A função abaixo é utilizada para estimar as variâncias desconhecidas do modelo e deve sempre ser colocada no environment do R:\n\n\nCarregando pacotes exigidos: dlm\n\n\nWarning: package 'dlm' was built under R version 4.3.1\n\n\nTambém pode-se mostrar que \\(\\theta_{t-h}|D_t\\) tem distribuição normal. Como se trata da distribuição dos estados após verificar toda a série temporal, esta é a distribuição para a suavização."
  },
  {
    "objectID": "polinomial.html",
    "href": "polinomial.html",
    "title": "6  Modelo linear dinâmico polinomial",
    "section": "",
    "text": "require(dlm)\n\nCarregando pacotes exigidos: dlm\n\n\nWarning: package 'dlm' was built under R version 4.3.1\n\nmodFim &lt;- function(y,mod){\n\n    ffbs &lt;- dlmGibbsDIG(y, mod = mod, n.sample = 5000,\n                    a.y=1,b.y=100,a.theta=1,b.theta=100,\n                    save.states = FALSE, thin = 0)\n\nv_sim  &lt;- sample(ffbs$dV[-(1:2500)],2500,T)\n\nq &lt;- dim(ffbs$dW)[2]\nw_sim &lt;- NULL\nfor(j in 1:q){\n w_sim &lt;- c(w_sim, mean(sample(ffbs$dW[,j][-(1:2500)],2500,T)))\n}\n# declarando as variâncias na quádrupla\nmod$V &lt;- mean(v_sim)\nmod$W &lt;- diag( w_sim,q)\nreturn(mod)\n}\n\nOs modelos linearas dinâmicos polinomiais possuem uma função de previsão polinomial.\nOs podemos mais utilizados na prática são os de ordem 1 e 2, também conhecidos como modelo de nível e de tendência linear, respectivamente.\n\n7 O modelo de nível\nO modelo de ordem 1, também conhecido como modelo de nível, possui função de previsão da forma\n\\[f_t(h)=m_t,\\] onde \\(m_t\\) é a média da série para o tempo \\(t\\). Esse tipo de modelo é útil para séries temporais que possuem oscilações na média (ou nível) mas sem exibir uma tendência forte.\nConsidere, por exemplo, a série com valores anuais das cheias do Rio Nilo entre 1871 e 1970.\n\nNile &lt;- ts(Nile, start =1900)\nts.plot(Nile, lwd = 2)\n\n\n\nacf(Nile, lwd = 2)\n\n\n\n\nÉ possível notar que há autocorrelação na série, mas o correlograma não revela uma tendência forte. Abaixo mostramos a tendência estimada via loess.\n\ntempo &lt;- 1:length(Nile)\nlw &lt;- loess( Nile ~ tempo)\ntend &lt;- ts(lw$fitted, start = start(Nile))\n\nts.plot(Nile)\nlines(tend, lwd = 2, col = 'tomato')\n\n\n\n\nA tendência estimada via loess parece revelar um comportamento inicial de queda e depois meio século de valores oscilando em torno de do nível. Vamos analisar isso utilizando um modelo linear dinâmico para o nível.\nPrimeiro, vamos criar um objeto que possui os componentes \\(F\\) e \\(G\\) adequados. Para tanto, basta usar a função dlmPoly e escolher a ordem do modelo polinomial.\n\nlibrary(dlm)\nmod &lt;- dlmModPoly( order = 1)\n\nSe você tiver curiosidade, \\(F\\) e \\(G\\) estão guardados em lista, com os nomes FF e GG\nDentro do objeto mod há um componente denomina m0. Ele é a estimativa do nível antes de 1. Vamos simplesmente dizer que este é igual ao valor observado em 1900\n\nmod$m0 &lt;- Nile[1]\n\nAgora, vamos estimar as variâncias do modelo, para obter \\(V\\) e \\(W\\):\n\nmod &lt;- modFim( Nile, mod)\n\nAgora, vamos aplicar o Teorema de Bayes, através de uma série de atualizações conhecidas como Filtro de Kalman\n\nfiltro &lt;- dlmFilter(Nile, mod)\n\nEm modelos lineares dinâmicos, definimos o erro de previsão por\n\\[y_t-E(y_t|D_{t-1})=y_t-f_t.\\] Se todos os sinais foram bem ajustados, os erros de previsão possuem comportamento com um ruído branco. O valor de \\(f_t\\) está no objeto filtro.\n\nerro &lt;- Nile - filtro$f\nts.plot(erro)\n\n\n\nacf(erro)\n\n\n\n\nAgora, vamos reaplicar o Teorema de Bayes, considerando a amostra toda, para obter a estimativa suavizada do nível.\n\nsuave &lt;- dlmSmooth(filtro)\n\nts.plot(Nile)\nlines( suave$s, lwd = 2, col = 'seagreen')\n\n\n\n\nTambém podemos fazer um intervalo de credibidade para o nível suavizado.\n\nts.plot(Nile)\nlines( suave$s, lwd = 2, col = 'seagreen')\n\n# variâncias da suavização\nvs &lt;- dlmSvd2var(suave$U.S, suave$D.S)\n\n# intervalo de credibilidade\nlines( suave$s - 1.96*sqrt(unlist(vs)) )\nlines( suave$s + 1.96*sqrt(unlist(vs)) )\n\n\n\n\nPodemos fazer previsões com a função\n\nprev &lt;- dlmForecast(filtro, 3)\nprev$f\n\nTime Series:\nStart = 2000 \nEnd = 2002 \nFrequency = 1 \n     Series 1\n[1,] 790.9126\n[2,] 790.9126\n[3,] 790.9126\n\n\n\n\n8 O modelo de tendência\nO modelo linear dinâmico polinomial de segunda ordem é um modelo de tendência, uma vez que sua função de previsão é\n\\[f_t(h)=m_{1,t}+m_{2,t}h.\\]\nAqui, existem dois estados para cada tempo: \\(\\theta_{1,t}\\) e \\(\\theta_{2,t}\\). No tempo \\(t\\), a média a posteriori dos estados possui a seguinte interpretação:\n\n\\(m_{1,t}\\): é o nível (média) da série no tempo \\(t\\), estimado com todos os dados disponíveis até o tempo \\(t\\)\n\\(m_{2,t}:\\) é a inclinação da tendência da série no tempo \\(t\\), estimado com todos os dados disponíveis até o tempo \\(t\\). Em particular, \\(m_{2,t}&gt;0\\) indica tendência de crescimento, enquanto que \\(m_{2,t}&lt;0\\) indica decrescimento.\n\nVoltemos à série de acidentes aéreos mensais. `\n\nts.plot(fab_mes, ylab = 'No acidentes/mês')\n\n\n\nacf(fab_mes, main='')\n\n\n\n\nVamos construir um modelo linear para a tendência:\n\nrequire(dlm)\nmod &lt;- dlmModPoly(2)\n\nEm seguida, precisamos dar uma informação inicial sobre os estados no tempo \\(0\\) (ou seja, a média do nível e da tendência antes da série ser observada). Um bom começo é supor que \\(m_{1,0}\\) é o valor \\(y_1\\) - o primeiro valor observado. Além disso, é usual iniciar a análise supondo que a tendência é nula.\n\nmod$m0 &lt;- c(fab_mes[1],0)\n\nAgora, vamos estimar a variâncias do modelo:\n\nmod &lt;- modFim(fab_mes, mod)\n\nVamos estimar os parâmetros dos estados via filtro de Kalman.\n\nfiltro &lt;- dlmFilter(fab_mes, mod)\n\nVamos analisar os erros de previsão.\n\nerros &lt;- fab_mes - filtro$f\nts.plot(erros)\n\n\n\nacf(erros)\n\n\n\n\nAmbos os gráficos acima mostram um comportamento de ruído branco. Também é esperado que, com o aumento do \\(t\\),\n\\[z_i=\\frac{y_t-f_t}{\\sqrt{Q_t}}\\sim N(0,1)\\] Não há uma função implementada no pacote dlm para este fim, e criamos a função abaixo para verificar a normalidade \\(z_i\\).\n\ndlmErros &lt;- function(filtro){\n  mod &lt;- filtro$mod\n  V &lt;- mod$V\n  FF &lt;- mod$FF\n  GG &lt;- mod$GG\n  y &lt;- filtro$y\n  f &lt;- filtro$f\n  \n  z &lt;- NULL\n  for(i in 1:length(y)){\n    R &lt;-  dlmSvd2var( filtro$U.R[[i]], filtro$D.R[i,])\n   z[i] &lt;- (y[i] - f[i])/sqrt( V + drop(FF %*% R %*% t(FF)))     \n  }\n  qqnorm(z)\n  abline(0,1)\n  sp &lt;- shapiro.test(z)\n  text(1.5,-2,paste0('Shapiro-Wilk normality test'))\n  text(1.5,-2.5,paste0('p-valor: ', round(sp$p.value,5)))\n  \n}\n\n\ndlmErros(filtro)\n\n\n\n\nPodemos fazer previsões mais longas com este modelo. Abaixo vamos prever o número de acidentes para os próximos 12 meses.\n\nprevisao12 &lt;- dlmForecast(filtro,12)\nprevisao12$f\n\n          Jan      Feb      Mar      Apr      May      Jun      Jul      Aug\n2023                                                       52.02514 52.09319\n2024 52.43341 52.50145 52.56950 52.63754 52.70558 52.77363                  \n          Sep      Oct      Nov      Dec\n2023 52.16123 52.22928 52.29732 52.36536\n2024                                    \n\n\nVamos colocar essas informações em um gráfico. Vamos começar com as previsões um passo a frente, que são utilizadas para o cálculo do erro de previsão e queforam realizadas dentro do filtro de Kalman - notem que vamos começar as previsões em março, uma vez que as outras foram irreais). Em seguida, vamos apresentar as previsões com um intervalo de 90% de predição (não se usa 95% para previsões porque os intervalos em geral são grandes demais)\n\nts.plot(fab_mes,xlim=c(2013,2025), ylab='No. acidentes mensais', ylim=c(0,75))\nlines( window(filtro$f,start=c(2013,3)), lty=2,lwd = 2)\n\n# medidas para o intervalo de previsão\nmedia_prev &lt;- previsao12$f\nmedia_prev &lt;- ts(media_prev, start = c(2023,7), frequency = 12)\n\ndesv_prev &lt;- sqrt( unlist( previsao12$Q))\ndesv_prev &lt;- ts(desv_prev, start = c(2023,7), frequency = 12)\n\n# intervalo de 90% para as previsões\nlines(media_prev, lwd = 2, col ='blue')\nlines(media_prev -1.64*desv_prev, lwd = 2, col ='blue')\nlines(media_prev+1.64*desv_prev, lwd = 2, col ='blue')\n\n# legenda\nlegend('bottomleft',c('Série observada','Previsão 1 passo à frente', 'Previsão de 12 meses'), lty=c(1,2,1), col =c(1,1,'blue'), bty = 'n')\n\n\n\n\nAgora vamos estudar os estados suavizados. `\n\nsuave &lt;- dlmSmooth(filtro)\n\nA obtenção das variâncias é mais delicada. Em cada instante de tempo, é calculada a matriz\n\\[S_t=\\left( \\begin{array}{cc} s_{11,t} & s_{12,t}\\\\s_{12,t}&s_{22,t}\\end{array}\\right),\\] que reprenta em sua diagonal a variância dos estados e fora dela a covariância entre eles. Por motivos computacionais, a matriz \\(S_t\\) não é computada diretamente, mas sim duas matrizes \\(U_t\\) e \\(D_t\\) tais que\n\\[S_t=U_t D_t U_t'\\] Essa decomposição, conhecida como espectral, possui vantagens numéricas que facilitam o processo de inversão necessário no filtro de Kalman. A função abaixo recupera o desvio padrão a partir de \\(U_t\\) e \\(D_t\\).\n\nsdSmooth &lt;- function(suave){\n  n &lt;- nrow(suave$s)\n  q &lt;- ncol(suave$s)\n  dp &lt;- array(NA_real_, c( n , q))\n  for(i in 1:n){\n    S &lt;- dlmSvd2var(suave$U.S[[i]],suave$D.S[i,])\n    dp[i,] &lt;- sqrt( diag(S))\n  }\n  dp\n}\n\nAbaixo, vamos obter os desvios da suavização\n\nsd &lt;- sdSmooth(suave)\n\nVamos começar a análise com o nível. Observe que, como são 2 estados, devemos selecionar a coluna 1.\n\nnivel_medio &lt;- suave$s[,1]\nsd_nivel &lt;- sd[,1]\n\nts.plot(fab_mes)\nlines(nivel_medio, lwd = 2, col = 'seagreen')\n\n# intervalor de credibilidade (95%) para o nível\nlines(nivel_medio - 1.96*sd_nivel, lwd = 2, col = 'seagreen', lty= 2)\nlines(nivel_medio + 1.96*sd_nivel, lwd = 2, col = 'seagreen', lty=2)\n\n\n\n\nPor último, vamos analisar a inclinação da tendência. Como a média da série já foi modelada pelo nível, os gráficos das demais componentes não são colocados sobre a série original. Abaixo mostramos o gráfico da inclinação, com seu respectivo intervalo.\n\ntend &lt;- suave$s[,2]\nsd_tend &lt;- sd[,2]\nts.plot(tend, lwd = 2, ylim=c(-1.5,1), ylab='Inclinação da tendência')\nlines(tend-1.96*sd_tend)\nlines(tend+1.96*sd_tend)\nabline(h=0, lty = 2)\n\n# período de mudança da tendência de decrescente para crescente\nabline(v=2016+10/12, lty = 2)\npoints(2016+10/12,0, pch = 15, cex = 1.2)\ntext(2016+11/12,.1,'Oct 16', pos = 2)\n\n# identificando a desaceleração\nx &lt;- window(tend, start=c(2022,7) )\nabline(v=2022+7/12, lty = 2)\npoints(2022+7/12, x[1], pch = 15, cex = 1.2)\ntext(2022+7/12,x[1],'Jul 22', pos = 2)\n\n\n\n\nCom o gráfico acima, identificamos muitas características interessantes.\n\nNote que o zero está presente na maior parte do intervalo. Portanto, podemos apenas afirmar que em certos períodos, a tendência de crescimento/decrescimento foram mais prováveis.\nEm relação à inclinação média, podemos afirmar que existem evidências de que o padrão de decrescimento estava desacelerando antes de 2016, culminando na inflexão em outubro. Nesse período a série passou a ter uma taxa de crescimento relativamente constante até Julho de 2022, quando começou a desaceler."
  },
  {
    "objectID": "sazonal.html#a-soma-de-um-ciclo-sazonal",
    "href": "sazonal.html#a-soma-de-um-ciclo-sazonal",
    "title": "7  Modelos lineares dinâmicos sazonais",
    "section": "7.1 A soma de um ciclo sazonal",
    "text": "7.1 A soma de um ciclo sazonal\nComo ilustração, considere um efeito sazonal trimestral (período 4). Considere os seguintes fatores sazonais:\n\\[\\beta_t=\\left\\{\\begin{array}{ll}1,& t=1,5,9,\\ldots \\\\\n2,& t=2,6,10,\\ldots\\\\\n3,&t=3,7,11,\\ldots \\\\\n4,&t=4,8,12,\\ldots\\end{array}\\right.\\]\nNote que \\[\\beta_1+\\beta_2+\\beta_3+\\beta_4=10\\]\nTambém note que \\[\\beta_2+\\beta_3+\\beta_4+\\beta_5=10\\] e que o mesmo é verdade para a soma de 4 quaiquer fatores sazonais consecutivos. Pode-se provar que, para qualquer sinal sazonal, a soma de seu efeito considerando um intervalo de tempo igual ao período é constante.\nConsidere então que uma série com período 4, fatores sazonais desconhecidos e e uma uma tendência, do tipo \\[\\hbox{tendência}(t)=\\alpha+\\gamma t.\\] Então, para qualquer \\(k=0,1,2,\\ldots,\\)\n\\[y_{k+1}+y_{k+2}+y_{k+3}+y_{k+4}=4\\alpha+\\gamma(10+4k)+\\beta_1+\\beta_2+\\beta_3+\\beta_4\\]\nPortanto, se os dados forem agregados para construir uma série anual, é impossível estimar \\(\\alpha\\) e \\(\\beta_1+\\beta_2+\\beta_3+\\beta_4\\) em separado. Por isso, assuminos que a soma dos fatores sazonais deve ser nula. Intuitivamente, estamos dizendo que o nível da série não pode ser modelado pela tendência."
  },
  {
    "objectID": "sazonal.html#o-modelo-linear-dinâmico-para-fatores-sazonais",
    "href": "sazonal.html#o-modelo-linear-dinâmico-para-fatores-sazonais",
    "title": "7  Modelos lineares dinâmicos sazonais",
    "section": "7.2 O modelo linear dinâmico para fatores sazonais",
    "text": "7.2 O modelo linear dinâmico para fatores sazonais\nConsidere uma série sazonal com período \\(p\\). No modelo linear dinâmico para fatores sazonais, assumimos que existem \\(p-1\\) fatores sazonais,\n\\[\\psi_1,\\ldots,\\psi_{p-1},\\] sendo que o \\(p\\)-ésimo fator é, necessariamente \\(-(\\psi_1-\\psi_2-\\cdots-\\psi_{p-1}\\). Além disso, permitimos que cada fator evolua no tempo, o que implica na notação \\(\\psi_t\\). Contudo, neste modelo consideramos apenas uma evolução de nível para os fatores (em um problema mensal, todos os janeiros estariam flutuando em torno de um nível, por exemplo). Por este motivo, a previsão para cada fator dentro dentro de uma determinada posição do ciclo sazonal será constante.\nA função dlmModSeas constrói as matrizes \\(F_t\\) e \\(G_t\\) para o modelo com fatores sazonais dinâmicos. Vamos ilustrar o uso deste modelo utilizando a série nottem - por didática, vamos remover a tendência da série via loess.\n\ntempo &lt;- 1:length(nottem)\ndnottem &lt;- nottem - loess( nottem ~ tempo)$fit\nts.plot(dnottem)\nabline(h=0,lty =2)\n\n\n\n\nJá identificamos, em outro momento, que o período desta série é 12, logo\n\nmod &lt;- dlmModSeas(12)\n\nPrecisamos colocar uma informação sobre os fatores sazonais. Vamos simplesmente assumir que todos valem zero.\n\nmod$m0 &lt;- rep(0,11)\n\nVamos estimar as variâncias:\n\nmod &lt;- modFim(dnottem, mod)\n\nEm seguida, aplicamos o filtro de Kalman e verificamos os erros de previsão:\n\nfiltro &lt;- dlmFilter(dnottem, mod)\n\nerro &lt;- dnottem - filtro$f\nts.plot(erro)\n\n\n\nacf(erro)\n\n\n\n\nPodemos notar que os erros foram altos no começo da série. Em geral, precisamos de pelos menos dois ciclos sazonais para ter uma previsão melhor. Já no correlograma, sobraram alguns elementos para serem explicados, como uma relação da série com as defasagens 1 e 2 e uma sazonalidade autoregressiva. Contudo, o comportamento sazonal, que era nosso objetivo, foi bem explicado.\nAs previsões vão se repetir após \\(12\\) unidades de tempo. Abaixo, fazemos a previsão para 2 anos.\n\nprevisao24 &lt;- dlmForecast(filtro,24)\nprevisao24$f\n\n             Jan         Feb         Mar         Apr         May         Jun\n1940  -9.5206529  -9.3739754  -6.5384935  -2.5977187   3.0850694   9.1938015\n1941  -9.5206529  -9.3739754  -6.5384935  -2.5977187   3.0850694   9.1938015\n             Jul         Aug         Sep         Oct         Nov         Dec\n1940  11.7308485  12.0444188   7.9602846  -0.4841747  -4.6829642 -10.8164433\n1941  11.7308485  12.0444188   7.9602846  -0.4841747  -4.6829642 -10.8164433\n\n\nVamos colocar essas informações em um gráfico.\n\nts.plot(dnottem,xlim=c(1920,1942), ylim=c(-20,20))\nlines( window(filtro$f,start=c(1920,12)), lty=2,lwd = 2)\n\n# medidas para o intervalo de previsão\nmedia_prev &lt;- previsao24$f\nmedia_prev &lt;- ts(media_prev, start = c(1940,1), frequency = 12)\n\ndesv_prev &lt;- sqrt( unlist( previsao24$Q))\ndesv_prev &lt;- ts(desv_prev, start = c(1940,1), frequency = 12)\n\n# intervalo de 90% para as previsões\nlines(media_prev, lwd = 2, col ='blue')\nlines(media_prev -1.64*desv_prev, lwd = 2, col ='blue')\nlines(media_prev+1.64*desv_prev, lwd = 2, col ='blue')\n\n# legenda\nlegend('bottomleft',c('Série observada','Previsão 1 passo à frente', 'Previsão de 24 meses'), lty=c(1,2,1), col =c(1,1,'blue'), bty = 'n')\n\n\n\n\nAgora vamos estudar os estados suavizados. `\n\nsuave &lt;- dlmSmooth(filtro)\nsd &lt;- sdSmooth(suave)\n\nComo o período é 12, existem \\(p-1=11\\) estados nesse modelo. Contudo, a matriz \\(G_t\\) é construída de modo que o primeiro estado sempre contém o fator sazonal da vez. Portanto, para poder analizar os fatores sazonais suavizados, basta selecionar a primeira coluna de s dentro do objeto suave\n\nnivel_medio &lt;- suave$s[,1]\nsd_nivel &lt;- sd[,1]\n\nts.plot(dnottem)\nlines(nivel_medio, lwd = 2, col = 'seagreen')\n\n# intervalor de credibilidade (95%) para o nível\nlines(nivel_medio - 1.96*sd_nivel, lwd = 2, col = 'seagreen', lty= 2)\nlines(nivel_medio + 1.96*sd_nivel, lwd = 2, col = 'seagreen', lty=2)"
  },
  {
    "objectID": "sazonal.html#exercícios",
    "href": "sazonal.html#exercícios",
    "title": "7  Modelos lineares dinâmicos sazonais",
    "section": "7.3 Exercícios",
    "text": "7.3 Exercícios"
  },
  {
    "objectID": "polinomial.html#o-modelo-de-nível",
    "href": "polinomial.html#o-modelo-de-nível",
    "title": "6  Modelo linear dinâmico polinomial",
    "section": "6.1 O modelo de nível",
    "text": "6.1 O modelo de nível\nO modelo de ordem 1, também conhecido como modelo de nível, possui função de previsão da forma\n\\[f_t(h)=m_t,\\] onde \\(m_t\\) é a média da série para o tempo \\(t\\). Esse tipo de modelo é útil para séries temporais que possuem oscilações na média (ou nível) mas sem exibir uma tendência forte.\nConsidere, por exemplo, a série com valores anuais das cheias do Rio Nilo entre 1871 e 1970.\n\nNile &lt;- ts(Nile, start =1900)\nts.plot(Nile, lwd = 2)\n\n\n\nacf(Nile, lwd = 2)\n\n\n\n\nÉ possível notar que há autocorrelação na série, mas o correlograma não revela uma tendência forte. Abaixo mostramos a tendência estimada via loess.\n\ntempo &lt;- 1:length(Nile)\nlw &lt;- loess( Nile ~ tempo)\ntend &lt;- ts(lw$fitted, start = start(Nile))\n\nts.plot(Nile)\nlines(tend, lwd = 2, col = 'tomato')\n\n\n\n\nA tendência estimada via loess parece revelar um comportamento inicial de queda e depois meio século de valores oscilando em torno de do nível. Vamos analisar isso utilizando um modelo linear dinâmico para o nível.\nPrimeiro, vamos criar um objeto que possui os componentes \\(F\\) e \\(G\\) adequados. Para tanto, basta usar a função dlmPoly e escolher a ordem do modelo polinomial.\n\nlibrary(dlm)\nmod &lt;- dlmModPoly( order = 1)\n\nSe você tiver curiosidade, \\(F\\) e \\(G\\) estão guardados em lista, com os nomes FF e GG\nDentro do objeto mod há um componente denomina m0. Ele é a estimativa do nível antes de 1. Vamos simplesmente dizer que este é igual ao valor observado em 1900\n\nmod$m0 &lt;- Nile[1]\n\nAgora, vamos estimar as variâncias do modelo, para obter \\(V\\) e \\(W\\):\n\nmod &lt;- modFim( Nile, mod)\n\nAgora, vamos aplicar o Teorema de Bayes, através de uma série de atualizações conhecidas como Filtro de Kalman\n\nfiltro &lt;- dlmFilter(Nile, mod)\n\nEm modelos lineares dinâmicos, definimos o erro de previsão por\n\\[y_t-E(y_t|D_{t-1})=y_t-f_t.\\] Se todos os sinais foram bem ajustados, os erros de previsão possuem comportamento com um ruído branco. O valor de \\(f_t\\) está no objeto filtro.\n\nerro &lt;- Nile - filtro$f\nts.plot(erro)\n\n\n\nacf(erro)\n\n\n\n\nAgora, vamos reaplicar o Teorema de Bayes, considerando a amostra toda, para obter a estimativa suavizada do nível.\n\nsuave &lt;- dlmSmooth(filtro)\n\nts.plot(Nile)\nlines( suave$s, lwd = 2, col = 'seagreen')\n\n\n\n\nTambém podemos fazer um intervalo de credibidade para o nível suavizado.\n\nts.plot(Nile)\nlines( suave$s, lwd = 2, col = 'seagreen')\n\n# variâncias da suavização\nvs &lt;- dlmSvd2var(suave$U.S, suave$D.S)\n\n# intervalo de credibilidade\nlines( suave$s - 1.96*sqrt(unlist(vs)) )\nlines( suave$s + 1.96*sqrt(unlist(vs)) )\n\n\n\n\nPodemos fazer previsões com a função\n\nprev &lt;- dlmForecast(filtro, 3)\nprev$f\n\nTime Series:\nStart = 2000 \nEnd = 2002 \nFrequency = 1 \n     Series 1\n[1,] 789.7686\n[2,] 789.7686\n[3,] 789.7686"
  },
  {
    "objectID": "polinomial.html#o-modelo-de-tendência",
    "href": "polinomial.html#o-modelo-de-tendência",
    "title": "6  Modelo linear dinâmico polinomial",
    "section": "6.2 O modelo de tendência",
    "text": "6.2 O modelo de tendência\nO modelo linear dinâmico polinomial de segunda ordem é um modelo de tendência, uma vez que sua função de previsão é\n\\[f_t(h)=m_{1,t}+m_{2,t}h.\\]\nAqui, existem dois estados para cada tempo: \\(\\theta_{1,t}\\) e \\(\\theta_{2,t}\\). No tempo \\(t\\), a média a posteriori dos estados possui a seguinte interpretação:\n\n\\(m_{1,t}\\): é o nível (média) da série no tempo \\(t\\), estimado com todos os dados disponíveis até o tempo \\(t\\)\n\\(m_{2,t}:\\) é a inclinação da tendência da série no tempo \\(t\\), estimado com todos os dados disponíveis até o tempo \\(t\\). Em particular, \\(m_{2,t}&gt;0\\) indica tendência de crescimento, enquanto que \\(m_{2,t}&lt;0\\) indica decrescimento.\n\nVoltemos à série de acidentes aéreos mensais. `\n\nts.plot(fab_mes, ylab = 'No acidentes/mês')\n\n\n\nacf(fab_mes, main='')\n\n\n\n\nVamos construir um modelo linear para a tendência:\n\nrequire(dlm)\nmod &lt;- dlmModPoly(2)\n\nEm seguida, precisamos dar uma informação inicial sobre os estados no tempo \\(0\\) (ou seja, a média do nível e da tendência antes da série ser observada). Um bom começo é supor que \\(m_{1,0}\\) é o valor \\(y_1\\) - o primeiro valor observado. Além disso, é usual iniciar a análise supondo que a tendência é nula.\n\nmod$m0 &lt;- c(fab_mes[1],0)\n\nAgora, vamos estimar a variâncias do modelo:\n\nmod &lt;- modFim(fab_mes, mod)\n\nVamos estimar os parâmetros dos estados via filtro de Kalman.\n\nfiltro &lt;- dlmFilter(fab_mes, mod)\n\nVamos analisar os erros de previsão.\n\nerros &lt;- fab_mes - filtro$f\nts.plot(erros)\n\n\n\nacf(erros)\n\n\n\n\nAmbos os gráficos acima mostram um comportamento de ruído branco.\nPodemos fazer previsões mais longas com este modelo. Abaixo vamos prever o número de acidentes para os próximos 12 meses.\n\nprevisao12 &lt;- dlmForecast(filtro,12)\nprevisao12$f\n\n          Jan      Feb      Mar      Apr      May      Jun      Jul      Aug\n2023                                                       51.77063 51.81681\n2024 52.04769 52.09386 52.14004 52.18621 52.23239 52.27857                  \n          Sep      Oct      Nov      Dec\n2023 51.86298 51.90916 51.95533 52.00151\n2024                                    \n\n\nVamos colocar essas informações em um gráfico. Vamos começar com as previsões um passo a frente, que são utilizadas para o cálculo do erro de previsão e queforam realizadas dentro do filtro de Kalman - notem que vamos começar as previsões em março, uma vez que as outras foram irreais). Em seguida, vamos apresentar as previsões com um intervalo de 90% de predição (não se usa 95% para previsões porque os intervalos em geral são grandes demais)\n\nts.plot(fab_mes,xlim=c(2013,2025), ylab='No. acidentes mensais', ylim=c(0,75))\nlines( window(filtro$f,start=c(2013,3)), lty=2,lwd = 2)\n\n# medidas para o intervalo de previsão\nmedia_prev &lt;- previsao12$f\nmedia_prev &lt;- ts(media_prev, start = c(2023,7), frequency = 12)\n\ndesv_prev &lt;- sqrt( unlist( previsao12$Q))\ndesv_prev &lt;- ts(desv_prev, start = c(2023,7), frequency = 12)\n\n# intervalo de 90% para as previsões\nlines(media_prev, lwd = 2, col ='blue')\nlines(media_prev -1.64*desv_prev, lwd = 2, col ='blue')\nlines(media_prev+1.64*desv_prev, lwd = 2, col ='blue')\n\n# legenda\nlegend('bottomleft',c('Série observada','Previsão 1 passo à frente', 'Previsão de 12 meses'), lty=c(1,2,1), col =c(1,1,'blue'), bty = 'n')\n\n\n\n\nAgora vamos estudar os estados suavizados. `\n\nsuave &lt;- dlmSmooth(filtro)\n\nA obtenção das variâncias é mais delicada. Em cada instante de tempo, é calculada a matriz\n\\[S_t=\\left( \\begin{array}{cc} s_{11,t} & s_{12,t}\\\\s_{12,t}&s_{22,t}\\end{array}\\right),\\] que reprenta em sua diagonal a variância dos estados e fora dela a covariância entre eles. Por motivos computacionais, a matriz \\(S_t\\) não é computada diretamente, mas sim duas matrizes \\(U_t\\) e \\(D_t\\) tais que\n\\[S_t=U_t D_t U_t'\\] Essa decomposição, conhecida como espectral, possui vantagens numéricas que facilitam o processo de inversão necessário no filtro de Kalman. A função abaixo recupera o desvio padrão a partir de \\(U_t\\) e \\(D_t\\).\n\nsdSmooth &lt;- function(suave){\n  n &lt;- nrow(suave$s)\n  q &lt;- ncol(suave$s)\n  dp &lt;- array(NA_real_, c( n , q))\n  for(i in 1:n){\n    S &lt;- dlmSvd2var(suave$U.S[[i]],suave$D.S[i,])\n    dp[i,] &lt;- sqrt( diag(S))\n  }\n  dp\n}\n\nAbaixo, vamos obter os desvios da suavização\n\nsd &lt;- sdSmooth(suave)\n\nVamos começar a análise com o nível. Observe que, como são 2 estados, devemos selecionar a coluna 1.\n\nnivel_medio &lt;- suave$s[,1]\nsd_nivel &lt;- sd[,1]\n\nts.plot(fab_mes)\nlines(nivel_medio, lwd = 2, col = 'seagreen')\n\n# intervalor de credibilidade (95%) para o nível\nlines(nivel_medio - 1.96*sd_nivel, lwd = 2, col = 'seagreen', lty= 2)\nlines(nivel_medio + 1.96*sd_nivel, lwd = 2, col = 'seagreen', lty=2)\n\n\n\n\nPor último, vamos analisar a inclinação da tendência. Como a média da série já foi modelada pelo nível, os gráficos das demais componentes não são colocados sobre a série original. Abaixo mostramos o gráfico da inclinação, com seu respectivo intervalo.\n\ntend &lt;- suave$s[,2]\nsd_tend &lt;- sd[,2]\nts.plot(tend, lwd = 2, ylim=c(-1.5,1), ylab='Inclinação da tendência')\nlines(tend-1.96*sd_tend)\nlines(tend+1.96*sd_tend)\nabline(h=0, lty = 2)\n\n# período de mudança da tendência de decrescente para crescente\nabline(v=2016+10/12, lty = 2)\npoints(2016+10/12,0, pch = 15, cex = 1.2)\ntext(2016+11/12,.1,'Oct 16', pos = 2)\n\n# identificando a desaceleração\nx &lt;- window(tend, start=c(2022,7) )\nabline(v=2022+7/12, lty = 2)\npoints(2022+7/12, x[1], pch = 15, cex = 1.2)\ntext(2022+7/12,x[1],'Jul 22', pos = 2)\n\n\n\n\nCom o gráfico acima, identificamos muitas características interessantes.\n\nNote que o zero está presente na maior parte do intervalo. Portanto, podemos apenas afirmar que em certos períodos, a tendência de crescimento/decrescimento foram mais prováveis.\nEm relação à inclinação média, podemos afirmar que existem evidências de que o padrão de decrescimento estava desacelerando antes de 2016, culminando na inflexão em outubro. Nesse período a série passou a ter uma taxa de crescimento relativamente constante até Julho de 2022, quando começou a desacelar."
  },
  {
    "objectID": "polinomial.html#exercícios",
    "href": "polinomial.html#exercícios",
    "title": "6  Modelo linear dinâmico polinomial",
    "section": "6.3 Exercícios",
    "text": "6.3 Exercícios\n\nAbaixo, mostramos o número de homicídios mensais em Manaus entre Janeiro de 1979 e Dezembro de 2009.\n\nurl &lt;- 'https://www.dropbox.com/s/hcqq6uhgwnimpcn/homicidios_manaus_SIM.csv?dl=1'\n\n\nExplore a série.\nEstude o nível da série\nEstude o comportamento da inclinação, identificando possíveis regimes de aceleração/desaceleração de crescimento.\n\n\n\nAnalise a série de suicídios no Mato Grosso do Sul, estudando o nível da série e a inclinação da tendência.\n\nurl &lt;- 'https://drive.google.com/uc?authuser=0&id=1DMSgrQDl0636Lw0Y0MYJHJrgw_2uXntM&export=download'"
  }
]