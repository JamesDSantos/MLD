# Modelo linear dinâmico polinomial

```{r}
require(dlm)

modFim <- function(y,mod){

    ffbs <- dlmGibbsDIG(y, mod = mod, n.sample = 5000,
                    a.y=1,b.y=100,a.theta=1,b.theta=100,
                    save.states = FALSE, thin = 0)

v_sim  <- sample(ffbs$dV[-(1:2500)],2500,T)

q <- dim(ffbs$dW)[2]
w_sim <- NULL
for(j in 1:q){
 w_sim <- c(w_sim, mean(sample(ffbs$dW[,j][-(1:2500)],2500,T)))
}
# declarando as variâncias na quádrupla
mod$V <- mean(v_sim)
mod$W <- diag( w_sim,q)
return(mod)
}
```

Os modelos linearas dinâmicos polinomiais possuem uma função de previsão polinomial.

Os podemos mais utilizados na prática são os de ordem 1 e 2, também conhecidos como modelo de nível e de tendência linear, respectivamente.

# O modelo de nível

O modelo de ordem 1, também conhecido como modelo de nível, possui função de previsão da forma

$$f_t(h)=m_t,$$ onde $m_t$ é a média da série para o tempo $t$. Esse tipo de modelo é útil para séries temporais que possuem oscilações na média (ou nível) mas sem exibir uma tendência forte.

Considere, por exemplo, a série com valores anuais das cheias do Rio Nilo entre 1871 e 1970.

```{r}
Nile <- ts(Nile, start =1900)
ts.plot(Nile, lwd = 2)
acf(Nile, lwd = 2)
```

É possível notar que há autocorrelação na série, mas o correlograma não revela uma tendência forte. Abaixo mostramos a tendência estimada via `loess`.

```{r}
tempo <- 1:length(Nile)
lw <- loess( Nile ~ tempo)
tend <- ts(lw$fitted, start = start(Nile))

ts.plot(Nile)
lines(tend, lwd = 2, col = 'tomato')

```

A tendência estimada via `loess` parece revelar um comportamento inicial de queda e depois meio século de valores oscilando em torno de do nível. Vamos analisar isso utilizando um modelo linear dinâmico para o nível.

Primeiro, vamos criar um objeto que possui os componentes $F$ e $G$ adequados. Para tanto, basta usar a função `dlmPoly` e escolher a ordem do modelo polinomial.

```{r}
library(dlm)
mod <- dlmModPoly( order = 1)
```

Se você tiver curiosidade, $F$ e $G$ estão guardados em lista, com os nomes `FF` e `GG`

Dentro do objeto `mod` há um componente denomina `m0`. Ele é a estimativa do nível antes de 1. Vamos simplesmente dizer que este é igual ao valor observado em 1900

```{r}
mod$m0 <- Nile[1]
```

Agora, vamos estimar as variâncias do modelo, para obter $V$ e $W$:

```{r}
mod <- modFim( Nile, mod)
```

Agora, vamos aplicar o Teorema de Bayes, através de uma série de atualizações conhecidas como Filtro de Kalman

```{r}
filtro <- dlmFilter(Nile, mod)
```

Em modelos lineares dinâmicos, definimos o erro de previsão por

$$y_t-E(y_t|D_{t-1})=y_t-f_t.$$
Se todos os sinais foram bem ajustados, os erros de previsão possuem comportamento com um ruído branco. O valor de $f_t$ está no objeto `filtro`.

```{r}
erro <- Nile - filtro$f
ts.plot(erro)
acf(erro)
```

Agora, vamos reaplicar o Teorema de Bayes, considerando a amostra toda, para obter a estimativa suavizada do nível.

```{r}
suave <- dlmSmooth(filtro)

ts.plot(Nile)
lines( suave$s, lwd = 2, col = 'seagreen')
```

Também podemos fazer um intervalo de credibidade para o nível suavizado.

```{r}
ts.plot(Nile)
lines( suave$s, lwd = 2, col = 'seagreen')

# variâncias da suavização
vs <- dlmSvd2var(suave$U.S, suave$D.S)

# intervalo de credibilidade
lines( suave$s - 1.96*sqrt(unlist(vs)) )
lines( suave$s + 1.96*sqrt(unlist(vs)) )
```

Podemos fazer previsões com a função 

```{r}
prev <- dlmForecast(filtro, 3)
prev
```


