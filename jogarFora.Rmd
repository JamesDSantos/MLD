---
title: "Untitled"
author: "James D Santos"
date: "2023-10-03"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(dlm)


modFim <- function(y,mod){
  ffbs <- dlmGibbsDIG(y, mod = mod, n.sample = 5000,
                    a.y=1,b.y=100,a.theta=1,b.theta=100,
                    save.states = FALSE, thin = 0)

v_sim  <- sample(ffbs$dV[-(1:2500)],2500,T)

q <- dim(ffbs$dW)[2]
w_sim <- NULL
for(j in 1:q){
 w_sim <- c(w_sim, mean(sample(ffbs$dW[,j][-(1:2500)],2500,T)))
}
# declarando as variâncias na quádrupla
mod$V <- mean(v_sim)
mod$W <- diag( w_sim)
return(mod)
}
Iw <- function(y,w){

  # matriz de planetamento
  n <- length(y)
  t <- 1:n
  x <- cbind(cos(2*pi*w*t), sin(2*pi*w*t))
  
  # coeficientes do modelo linear
  beta <- coefficients(lm(y ~x-1))
  
  # amplitude
  A <- sqrt(sum(beta^2))
  
  # Iw
  .5*n*A^2
}

periodograma <- function(y){
  # gráfico
  n <- length(y)
  w_detec <- ( 1 : floor(  (n-1)/ 2) ) / n
  I_w <- sapply( w_detec, function(w) Iw(y , w) )
  plot( 1 / w_detec , I_w, xlab = 'Período', ylab =     expression(I(w)), type = 'h' , lwd = 2)
  
  # encontrando o periodo
  fund <-  w_detec[ which( I_w == max(I_w))]
  cat('Período: ',1/fund,'\n')

}

tempo <- 1:length(nottem)
dnottem <- nottem - loess( nottem ~ tempo)$fit
```

## R Markdown

Vimos anteriormente que uma onda, de período $p$, pode ser representada pela função harmônica

$$g_1(t)=A_1\cos\left(\frac{2\pi}{p}t+\phi_1\right).$$
Acontece que é possível que existam outros ciclos dentro do de duração $p$.

Para ilustrar, vamos imaginar o caso no qual $p=12$. Então, temos uma onda se reinicia a cada $12$ meses, isto é,

$$g_1(t)=A_1\cos\left(\frac{2\pi}{12}t+\phi_1\right).$$
Acontece que é possível que existam
Porém podemos ter um outro efeito, que se renova a cada semestre. Nesse caso, teríamos outro harmônico para esse comportamento

$$g_2(t)=A_2\cos\left(\frac{2\pi}{6}t+\phi_2\right)$$

Também podemos ter um ciclo se repetindo a cada quatrimestre

$$g_3(t)=A_3\cos\left(\frac{2\pi}{4}t+\phi_3\right),$$
e outro a cada trimestre

$$g_4(t)=A_4\cos\left(\frac{2\pi}{3}t+\phi_4\right).$$

Então, o nosso padrão sazonal seria a soma desses harmônicos:

$$g(t)=\sum_{j=1}^4 g_{j}(t)=\sum_{j=1}^4 A_j\cos\left(\frac{2\pi}{p}jt+\phi_j\right).$$
A função $g_j(t)$ é denominada $j$-ésimo harmônico e é possível ter $q$ harmônicos, onde $q$ é  a parte inteira de $p/2$.

A figura abaixo ilustra essa ideia.

```{r echo = F}
x<- seq(1,12,.5)
`Harmônico 1` <- cos(x*2*pi/12)
`Harmônico 2` <- cos(x*2*pi/6)
`Harmônico 3` <- cos(x*2*pi/4)
`Harmônico 4` <- cos(x*2*pi/3)
`Padrão final` <- `Harmônico 1`+
  `Harmônico 2`+ `Harmônico 3` + `Harmônico 4`
plot.ts(cbind(`Harmônico 1`,`Harmônico 2`,`Harmônico 3`,`Harmônico 4`,`Padrão final`), main = '')


```

No caso geral, para um período $p$, podemos converter o modelo acima em um modelo linear

$$g(t)=\sum_{j=1}^{q} \beta_{1,j}\cos\left(\frac{2\pi}{p}jt\right)+\beta_{2,j}\sin\left(\frac{2\pi}{p}jt\right).$$
De fato, existe $\boldsymbol{F}_t'$ tal que 

$$g(t)=\boldsymbol{F}_t'\boldsymbol{\beta},$$
onde $\boldsymbol{\beta}$ é um vetor contendo $\beta_{1,1},\beta_{1,2},\ldots,\beta_{1,q},\beta_{2,q}$. O modelo

$$y_t= \boldsymbol{F}_t'\boldsymbol{\beta}+\varepsilon_t$$
é denominado regressão harmônica. Assumindo que o vetor de parâmetros pode evoluir no tempo $t$, considerando uma estrutura de nível, teremos o modelo de regressão harmônica dinâmico.

Vamos analisar a série `dnottem` utilizando esse modelo com apenas um harmônico. A função `dlmModTrig(p,q)` cria as matrizes necessárias para o modelo de regressão harmônica com período $p$ e $q$ harmônicos (se omitido, serão utilizados $p/2$ harmônicos). 

```{r}
mod <- dlmModTrig(12, 1)
mod <- modFim( dnottem, mod)
```
Vamos aplicar o filtro de Kalman:

```{r}
filtro <- dlmFilter(dnottem,mod)
```

A previsão é semelhante ao que já fizemos, então vamos apenas analisar os erros de previsão.

```{r}
erros <- dnottem - filtro$f
ts.plot(erros)
acf(erros)
```


Note que o padrão sazonal não foi todo explicado. Abaixo utilizamos a função periodograma nos erros de previsão.

```{r}
periodograma(erros)
```

Note que o período encontrado é 6 - isso corresponde ao harmônico 2, uma vez que 12/2=6. Vamos reescrever nosso modelo colocando os dois primeiros harmônicos.

```{r}
mod <- dlmModTrig(12, 2)
mod <- modFim( dnottem, mod)
filtro <- dlmFilter(dnottem,mod)
erros <- dnottem - filtro$f
ts.plot(erros)
acf(erros)
```

Agora toda a parte sazonal foi explicada. Isso implica que existem dois comportamentos: um ciclo sazonal com duração de 12 meses e outro com duração de 6 meses.

A amplitude é sem dúvidas uma medida importante, uma vez que ela mede a magnitude do harmônico. Vamos obter as estimativas suavizadas das duas amplitudes.

```{r}
suave <- dlmSmooth(filtro)
```

Em `suave$s`, obtemos as estimativas suavizadas para os estados da regressão harmônica. São quatro colunas, sendo que as duas primeiras são referentes ao harmônico 1 e as duas seguinda ao 2. Vamos recuperar as amplitudes:

```{r}
A1 <- sqrt( suave$s[,1]^2 + suave$s[,2]^2 )
A2 <- sqrt( suave$s[,3]^2 + suave$s[,4]^2 )

plot.ts( cbind(A1, A2), lwd = 2)
```

Podemos perceber que houve um leve aumento do nível da amplitude do efeito sazonal anual, indo de 10 para 12 unidades, entre 1920 e 1934 (série A1). Já o efeito semestral, com influência bem menor, apresentou padrões de tendência crescente e decrescente ao longo do tempo.

## A superposição de modelos lineares dinâmicos

Podemos imaginar que uma série temporal $y_t$ é a soma de várias séries ocultas. Por exemplo, considere que 

$y_t=x_t+u_t$

onde $x_t$ é uma série que possui apenas a tendência da série e $u_t$ a parte sazonal.

<div class='alert alert-success'>
<strong>Teorema.</strong> Se $x_t$ e $u_t$ são modelos lineares dinâmicos, então $y_t$ também é um modelo linear dinâmico.
</div>

Deste modo, podemos somar modelos lineares dinâmicos para analizar diferentes tipos de sinal.

Considere a série `ldeaths`, que já sabemos possuir uma leve tendência linear de decrescimento e um forte sinal sazonal de período 12. Podemos ajustar um modelo linear dinâmico com essas duas características.

```{r}
mod <- dlmModPoly(2) + dlmModSeas(12)
mod$m0[1] <- ldeaths[1]
mod <- modFim(ldeaths, mod)

filtro <- dlmFilter(ldeaths, mod)
erro <- ldeaths - filtro$f

ts.plot(erro)
acf(erro)
```

Os gráficos acima apontam que os sinais de tendêcia e sazonalidade estão bem descritos. Vamos fazer a previsão para 12 meses a frente:

```{r}
previsao12 <- dlmForecast(filtro, 12)

ts.plot(ldeaths,xlim=c(1974,1981), ylim=c(-400,4000))
lines( window(filtro$f,start=c(1974,1)), lty=2,lwd = 2)

# medidas para o intervalo de previsão
media_prev <- previsao12$f
media_prev <- ts(media_prev, start = c(1980,1), frequency = 12)

desv_prev <- sqrt( unlist( previsao12$Q))
desv_prev <- ts(desv_prev, start = c(1980,1), frequency = 12)

# intervalo de 90% para as previsões
lines(media_prev, lwd = 2, col ='blue')
lines(media_prev -1.64*desv_prev, lwd = 2, col ='blue')
lines(media_prev+1.64*desv_prev, lwd = 2, col ='blue')

# legenda
legend('bottomleft',c('Série observada','Previsão 1 passo à frente', 'Previsão de 24 meses'), lty=c(1,2,1), col =c(1,1,'blue'), bty = 'n')

```

Também podemos estudar os elementos suavisados dos sinais:

```{r}
suave <- dlmSmooth(filtro)
sd <- sdSmooth(suave)

Nível <- suave$s[,1]
`Inc. tend` <- suave$s[,2]
`Fat. Saz` <- suave$s[,3]

plot.ts(cbind(Nível, `Inc. tend`,`Fat. Saz`), main = 'Componentes do sinal')
```

## Exercícios

<div class='alert alert-warning'>
<strong>Exercício 2</strong>

Analise as seguintes séries temporais:

* Óbitos maternos

* Número de nascidos vivos

* `co2`

* Taxa de desemprego

</div>

<div class='alert alert-warning'>
Analise as seguintes séries temporais:
<strong>Exercício 2</strong>
Compare a tendência e sazonalidade do número de nascidos vivos segundo os partos normal e cesário.
</div>
