[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introdução aos modelos lineares dinâmicos",
    "section": "",
    "text": "Prefácio",
    "crumbs": [
      "Prefácio"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Manipulação de séries temporais univariadas no software R",
    "section": "",
    "text": "1.1 Definição de séries temporais\nConsidere um fenômeno aleatório que é observado ao longo do tempo. A coleção de variáveis aleatórias indexadas no tempo, associadas a este fenômeno, é denominada série temporal. Neste caso, para cada instante de tempo \\(t\\), há uma variável \\(X(t)\\) associada.\nAlguns autores definem séries temporais simplesmente como valores observados ao longo do tempo.No entanto, essa definição não é útil para nós, uma vez que o tempo não necessariamente possui influência na variável, ou seja, é possível que a distribuição de \\(X(t)\\) não dependa de \\(t\\).\nA partir deste momento, \\(X(t)\\) será escrita como \\(X_t\\) e representará a variável aleatória associada ao tempo \\(t\\) e a versão minúscula \\(x_t\\) representará o valor observado.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Manipulação de séries temporais univariadas no software `R`</span>"
    ]
  },
  {
    "objectID": "intro.html#definição-de-séries-temporais",
    "href": "intro.html#definição-de-séries-temporais",
    "title": "1  Manipulação de séries temporais univariadas no software R",
    "section": "",
    "text": "Figure 1 - Ilustração de uma série temporal\n\n\n\n\nImportante: estamos interessados apenas em séries temporais nas quais o modelo de probabilidades depende do tempo \\(t\\).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Manipulação de séries temporais univariadas no software `R`</span>"
    ]
  },
  {
    "objectID": "intro.html#a-classe-ts-e-a-função-window",
    "href": "intro.html#a-classe-ts-e-a-função-window",
    "title": "1  Manipulação de séries temporais univariadas no software R",
    "section": "1.2 A classe ts e a função window",
    "text": "1.2 A classe ts e a função window\nNessa seção vamos distutir a classe ts do R. Ela é particularmente útil para fazer gráficos de séries temporais. A função ts possui vários argumentos importantes:\n\ndata: vetor ou matriz da série observada\nfrequency: esse valor representa o número de observações por período. Vamos discutir essa particularidade em outro momento, mas para a maioria das séries, o período é representado por um ano e o valor de frequency está relacionado com quantas observações são necessárias para completar um ano. Por exemplo, se os dados são registrados mensalmente, temos frequency=12. Em caso de trimestres, frequency=4. O valor padrão é frequency=1.\ndeltat: é o inverso do número de observações por período. Apenas um entre frequency e deltat deve ser dado.\nstart: representa o tempo no qual a série começa. Pode ser representado por um único número ou por um vetor de dois números, com o segundo representando o momento dentro do período. Por exemplo:\n\nse frequancy=12 (meses em um ano) então start=c(1996,2) implica que a primeira observação data de fevereiro de 1996.\nse frequancy=4 (trimestres em um ano) então start=c(1996,2) implica que a primeira observação data do segundo trimestre dede 1996.\n\nend: representa o tempo no qual a série termina. A sintaxe é a mesma do start\nnames: é um vetor com o nomes das séries. É utilizado apenas quando há mais de uma série temporal.\n\n\nExemplo\nVamos ilustrar a construção de um objeto ts`` utilizando a tabela abaixo, que apresenta o número de nascidos vivos por mês na cidade de Manaus em 2021.\n\n\n\nMês\nNo. nascidos vivos\n\n\n\n\nJaneiro\n3043\n\n\nFevereiro\n2902\n\n\nMarço\n3166\n\n\nAbril\n3014\n\n\nMaio\n3095\n\n\nJunho\n2955\n\n\nJulho\n3087\n\n\nAgosto\n3141\n\n\nSetembro\n3129\n\n\nOutubro\n3096\n\n\nNovembro\n3191\n\n\nDezembro\n3222\n\n\n\nVamos guarda a série no vetor x e construir o objeto y na classe ts.\n\nx &lt;- c(\n  3043, 2902, 3166, 3014,\n3095, 2955, 3087, 3141,\n3129, 3096, 3191, 3222\n\n)\ny &lt;- ts( x, start = c(2021,1), frequency = 12)\ny\n\n      Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec\n2021 3043 2902 3166 3014 3095 2955 3087 3141 3129 3096 3191 3222\n\n\nA função plot reconhece um objeto na classe ts e constrói um gráfico com o tempo devidamente marcado no eixo as abscissas.\n\nplot(y)\n\n\n\n\n\n\n\n\nOutros detalhes gráficos da função plot podem ser utilizados.\n\nplot(y, ylab = 'No. nascidos vivos', lwd = 2, col = 'seagreen', xlab = 'Ano', main = 'Série mensal de nascidos vivos em Manaus', sub='Fonte: Sistema de Informação sobre Nascidos Vivos/SUS')\n\n\n\n\n\n\n\n\n\nÉ possível extrair os argumentos de um ts já criado utilizando funções com os mesmos nomes dos respectivos argumentos. No exemplo acima, criamos o objeto denominado y. Abaixo, extraímos os argumentos deste objeto.\n\nstart(y)\n\n[1] 2021    1\n\nend(y)\n\n[1] 2021   12\n\nfrequency(y)\n\n[1] 12\n\ndeltat(y)\n\n[1] 0.08333333\n\n\nA função window é particularmente útil para selecionar um subconjunto da série temporal. Seus argumentos são os mesmos da função ts.\n\nExemplo Utilizando o mesmo conjunto de dados do exemplo anterior, vamos usar a função window para extrair apenas os nascimentos entre junho e agosto.\n\nz &lt;- window(y, start=c(2021,6), end = c(2021,8))\nz\n\n      Jun  Jul  Aug\n2021 2955 3087 3141\n\n\nAcima, z é um novo objeto ts. Podemos usar a função lines destacar a parte selecionada da série em um gráfico já existente. Abaixo, descatamos os dados selecionados em z.\n\nplot(y, ylab = 'No. nascidos vivos', lwd = 2, col = 'seagreen', xlab = 'Ano', main = 'Série \nmensal de nascidos vivos em Manaus', sub='Fonte: Sistema de Informação sobre Nascidos Vivos/SUS')\nlines(z, col ='brown', lwd = 4 )\n\n\n\n\n\n\n\n\n\n\nExercício 1\nA série abaixo representa o número de homicídios mensais no Amazonas, segundo causa básica de óbito, entre os anos 2000 e 2023.\n\nrequire(gsheet)\nurl = 'https://docs.google.com/spreadsheets/d/1rtiyOZ1W3SRIWZJTR1RyBmxmnGO11x005GNGrgLBr5A/edit?usp=sharing'\n\nhom = gsheet2tbl(url)\n\n\nConstrua um objeto do tipo ts\nFaça um gráfico da série.\nCrie um janela para marcar o período entre o início da pandemia de COVID-19 (março de 2020) e o primeiro dia sem mortes por COVID-19 (julho de 2021)\nRepresente a janela acima no gráfico anterior. O que esse gráfico revela?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Manipulação de séries temporais univariadas no software `R`</span>"
    ]
  },
  {
    "objectID": "intro.html#a-classe-date-e-o-pacote-lubridate",
    "href": "intro.html#a-classe-date-e-o-pacote-lubridate",
    "title": "1  Manipulação de séries temporais univariadas no software R",
    "section": "1.3 A classe Date e o pacote lubridate",
    "text": "1.3 A classe Date e o pacote lubridate\nNessa seção discutimos a classe Date, responsável por operações com datas no R. São apresentadas as principais funções do pacote base. Em seguida, apresentamos o pacote lubridate, que oferece funções adicionais e uma sintaxe mais fluida.\nNo pacote base, as datas são objeto da classe Date. Abaixo, transformamos o texto que representa 3 de agosto de 1998 nessa classe.\n\n# 3 de agosto de 1998 (formato americano)\nx &lt;- '1998/8/3'\ny &lt;- as.Date(x)\n\nExistem diversas funções que interagem com objetos nessa classe:\n\nweekdays: Retorna o dia da semana.\nmonths: Retorna o nome do mês.\nquarters: Retorna o trimestre do ano (Q1,Q2,Q3 ou Q4).\n\nAbaixo, ilustramos o uso dessas funções com a data 3 de agosto de 1998.\n\nweekdays(y)\n\n[1] \"segunda-feira\"\n\nmonths(y)\n\n[1] \"agosto\"\n\nquarters(y)\n\n[1] \"Q3\"\n\n\nOutra vantagem desta classe é a possibilidade de calcular a diferença em dias entre duas datas, utilizando a função -. Abaixo mostramos a diferença entre 3 de agosto de 1998 e 3 de agosto de 1999.\n\nz &lt;- as.Date('1999-08-03')\nz-y\n\nTime difference of 365 days\n\n\nEm certas aplicações, é necessário criar um vetor contendo datas em sequência. A função seq interage com objetos da classe Date, permitindo que o argumento by receba as strings day, week,month, quarter e year. Abaixo, criamos um vetor mensal que começa em 3 de agosto de 1998 e terminando e 3 de agosto de 1999.\n\ninicio &lt;- as.Date('1998-08-03')\nfim &lt;- as.Date('1999-08-03')\nseq(inicio, fim, by='month')\n\n [1] \"1998-08-03\" \"1998-09-03\" \"1998-10-03\" \"1998-11-03\" \"1998-12-03\"\n [6] \"1999-01-03\" \"1999-02-03\" \"1999-03-03\" \"1999-04-03\" \"1999-05-03\"\n[11] \"1999-06-03\" \"1999-07-03\" \"1999-08-03\"\n\n\nObserve que a conversão da string para Date é realizada considerando o formato americano por padrão. É possível usar a função as.Date para ler qualquer formato, modificando o argumento format. No entanto, o pacote lubridate oferece funções mais simples para essa conversão:\n\nymd: Converte strings no formato “ano, mês, dia”, como “2023-10-26”.\nmdy: Converte strings no formato “mês, dia, ano”, como “10-26-2023”.\ndmy: Converte strings no formato “dia, mês, ano”, como “26-10-2023”.\n\nAbaixo, transformamos a data 3/8/1998 para o formato americano.\n\nrequire(lubridate)\n# 3 de agosto de 1998 (formato nacional)\nx &lt;- '3/8/1998'\ndmy(x)\n\n[1] \"1998-08-03\"\n\n\nO lubridate também ofere a possibilidade de trabalhar com informações de tempo dentro de um dia, como horas, minutos e segundos. Por exemplo, a informação 15h30 de 3 de agosto de 1998 é lida como\n\nx &lt;- '3/8/1998 15:30:00'\ndmy_hms(x)\n\n[1] \"1998-08-03 15:30:00 UTC\"\n\n\nO lubridate possui as funções month e wday, que funcionam de modo análgo às funções months e weekdays. Além disso, o lubridate traz uma série de funções adicionais como:\n\nyear: retorna o ano de uma data\nday: retornam o dia de uma data (útil para o formado xxx-xx-xx 00:00:00)\nhour, minute, second: Retornam a hora, minuto e segundo de um objeto de data e tempo.\n\nAs funções de arredondamento de data também são úteis, especialmente para obter contagens mensais, anuais, etc. Elas são floor_date e ceiling_date e são responsáveis por arredondar uma data para o início ou o fim de um período, respectivamente. Abaixo, arredondamos a data 3 de agosto de 1998 para o começo do mês.\n\nx &lt;- dmy('03/08/1998')\nfloor_date(x, 'month')\n\n[1] \"1998-08-01\"\n\n\n\nExemplo\nA Força Aérea Brasileira (FAB), por meio do Centro de Investigação e Prevenção de Acidentes Aeronáuticos (CENIPA), possui um dashboard para explorar dados sobre incidentes e acidentes aéreos no Brasil. Um acidente é definido como uma ocorrência grave associada à operação de uma aeronave que resulta em lesões ou morte, dano estrutural da aeronave ou aeronave desaparecida. Os demais casos são classificados como incidentes. Os dados, atualizados em 11/08/2025, estão disponíveis para esse curso na url abaixo:\n\nurl &lt;- 'https://docs.google.com/spreadsheets/d/1BjTXFMmTpcxKdRHCr5IIDJde9yr0s3oAAfyj2vdVuX8/edit?usp=sharing'\n\naereo &lt;-  gsheet2tbl(url)\nhead(aereo)\n\n# A tibble: 6 × 10\n  Link   Data  Matrícula Classificação Tipo  Localidade UF    Aeródromo Operação\n  &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;         &lt;chr&gt; &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;   \n1 https… 05/0… ****      INCIDENTE     FALH… RIO DE JA… RJ    FAER      TÁXI AÉ…\n2 https… 04/0… ****      INCIDENTE     FALH… MARICÁ     RJ    NCAD      TÁXI AÉ…\n3 https… 01/0… ****      INCIDENTE     FALH… RIO DE JA… RJ    SBJR      TÁXI AÉ…\n4 https… 31/0… ****      INCIDENTE     FALH… PALMAS     TO    SBPJ      REGULAR \n5 https… 29/0… ****      INCIDENTE     FALH… BOA VISTA  RR    FAER      TÁXI AÉ…\n6 https… 29/0… ****      INCIDENTE     COLI… RECIFE     PE    SBRF      REGULAR \n# ℹ 1 more variable: Status &lt;chr&gt;\n\n\nA unidade amostral é o acidente/indicente. Estamos interessados em criar uma série temporal com o número de acidentes mensais. Abaixo, filtramos apenas os acidentes (coluna Classificção) e, em seguida, transformamos as datas em objetos do tipo Date.\n\nacidentes &lt;- aereo[ aereo$Classificação=='ACIDENTE', ]\ndatas &lt;- dmy(acidentes$Data)\n\nAgora, vamos arredondar todas as datas para o primeiro dia do mês. Em seguida, contaremos as frequências para cada mês/ano\n\nmes_ano &lt;- floor_date(datas, 'month')\ncontagem &lt;- table(mes_ano)\ncontagem\n\nmes_ano\n2015-01-01 2015-02-01 2015-03-01 2015-04-01 2015-05-01 2015-06-01 2015-07-01 \n        12         14         15         19         16         14         16 \n2015-08-01 2015-09-01 2015-10-01 2015-11-01 2015-12-01 2016-01-01 2016-02-01 \n        13         17          9         14         13         20         16 \n2016-03-01 2016-04-01 2016-05-01 2016-06-01 2016-07-01 2016-08-01 2016-09-01 \n        20         19          8          5         11          4         17 \n2016-10-01 2016-11-01 2016-12-01 2017-01-01 2017-02-01 2017-03-01 2017-04-01 \n        20          9         15         17         16         11         16 \n2017-05-01 2017-06-01 2017-07-01 2017-08-01 2017-09-01 2017-10-01 2017-11-01 \n         8          6         12          6         14         15         16 \n2017-12-01 2018-01-01 2018-02-01 2018-03-01 2018-04-01 2018-05-01 2018-06-01 \n         9         18         19         18         18         15         13 \n2018-07-01 2018-08-01 2018-09-01 2018-10-01 2018-11-01 2018-12-01 2019-01-01 \n        15          8         11          8         14         10         20 \n2019-02-01 2019-03-01 2019-04-01 2019-05-01 2019-06-01 2019-07-01 2019-08-01 \n        10         17         14         12         13         15          8 \n2019-09-01 2019-10-01 2019-11-01 2019-12-01 2020-01-01 2020-02-01 2020-03-01 \n        14          6         11         11         11         17         12 \n2020-04-01 2020-05-01 2020-06-01 2020-07-01 2020-08-01 2020-09-01 2020-10-01 \n        14          9          6         16          9         15         18 \n2020-11-01 2020-12-01 2021-01-01 2021-02-01 2021-03-01 2021-04-01 2021-05-01 \n         7         16         13         16         17          7         17 \n2021-06-01 2021-07-01 2021-08-01 2021-09-01 2021-10-01 2021-11-01 2021-12-01 \n         5          8          8         12          7         13         18 \n2022-01-01 2022-02-01 2022-03-01 2022-04-01 2022-05-01 2022-06-01 2022-07-01 \n        15         12         13         13          9         13          8 \n2022-08-01 2022-09-01 2022-10-01 2022-11-01 2022-12-01 2023-01-01 2023-02-01 \n         8         12         10         13         12         21         21 \n2023-03-01 2023-04-01 2023-05-01 2023-06-01 2023-07-01 2023-08-01 2023-09-01 \n        18         12         17         15          7          6          5 \n2023-10-01 2023-11-01 2023-12-01 2024-01-01 2024-02-01 2024-03-01 2024-04-01 \n         8         14         11         17         21         12         22 \n2024-05-01 2024-06-01 2024-07-01 2024-08-01 2024-09-01 2024-10-01 2024-11-01 \n         7         15         13          9         13         12         14 \n2024-12-01 2025-01-01 2025-02-01 2025-03-01 2025-04-01 2025-05-01 2025-06-01 \n        20         22         11         13         20         10          5 \n2025-07-01 \n        11 \n\n\nÉ sempre importante checar o resultado em contagem, para verificar se não há algum mês ausente. Como não o caso aqui, vamos construir um objeto do tipo ts e fazer o gráfico da série temporal.\n\nserie_acidentes &lt;- ts(contagem, start=c(2015,1), frequency = 12 )\nplot(serie_acidentes, ylab = 'No. de acidentes aéreos', xlab = 'Ano', sub= 'Fonte: CENIPA' )\n\n\n\n\n\n\n\n\n\n\nExercício 2\nA série abaixo contém as datas dos óbitos maternos no Brasil a partir de 2010.\n\nurl &lt;- 'https://drive.google.com/uc?authuser=0&id=1tYFFT9L2iopKmBDUI3P8qNIRaOnMYj7d&export=download'\n\nCrie uma série temporal com o número de óbitos mensal e faça um gráfico. Crie uma janela para destacar no gráfico o período da pandemia de COVID-19 (março de 2020 até julhode 2021).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Manipulação de séries temporais univariadas no software `R`</span>"
    ]
  },
  {
    "objectID": "estacionaria.html",
    "href": "estacionaria.html",
    "title": "2  Séries Estacionárias",
    "section": "",
    "text": "2.1 Processo estacionário ergódico\nSeja \\(x_1,x_2,\\ldots,x_n\\) uma série temporal estacionária. Então, a média \\(\\mu\\) pode ser estimada por \\(\\bar{x}_n\\), uma vez que \\(E(\\bar{x}_n)=\\mu\\). A variância dessa estatística é\n\\[\\begin{align}Var(\\bar{x}_n)&=Cov(\\bar{x}_n,\\bar{x}_n)=Cov\\left(\\sum_{i=1}^n \\frac{x_i}{n},\\sum_{j=1}^n\\frac{x_j}{n}\\right)=\\frac{1}{n^2}\\sum_{i=1}^n\\sum_{j=1}^nCov(x_i,x_j)\\\\\n&=\\frac{1}{n^2}\\left[\\sum_{i=1}^nCov(x_i,x_i)+2\\sum_{i=1}^n\\sum_{j\\neq i}Cov(x_i,x_j)\\right]\\\\\n&=\\frac{1}{n^2}\\left[n\\nu+2\\sum_{h=1}^{n-1}(n-h)\\gamma(h)\\right]=\\frac{\\nu}{n}+\\frac{2}{n}\\sum_{h=1}^{n-1}\\left(1-\\frac{h}{n}\\right)\\gamma(h)\n\\end{align}\\]\nNote que, diferente do caso independente e identicamente distribuído, \\(\\bar{x}\\) não é necessariamente um estimador adequado, conforme pode ser constatado no exemplo abaixo.\nA partir do exemplo acima, fica claro que \\(\\bar{x}\\) nem sempre será um estimador adequado para uma série estacionária.\nA partir deste momento será considerado que toda série temporal estacionária é ergódica e, portanto \\(\\bar{x}\\) é um estimador para \\(\\mu\\).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Séries Estacionárias</span>"
    ]
  },
  {
    "objectID": "estacionaria.html#processo-estacionário-ergódico",
    "href": "estacionaria.html#processo-estacionário-ergódico",
    "title": "2  Séries Estacionárias",
    "section": "",
    "text": "Example 2.3 Seja \\(x_t\\) um processo onde \\(x_0\\sim\\hbox{Normal}(0,\\nu)\\) e \\(x_t=x_0\\) para todo \\(t&gt;0\\). Como\n\\[\\begin{align}\nE(x_t)&=E(E(x_t|x_0))=E(x_0)=0\\\\\nVar(x_t)&=E(Var(x_t|x_0))+Var(E(x_t|x_0))=E(0)+Var(x_0)=\\nu\\\\\nCov(x_t,x_{t-h})&=E( Cov(x_t,x_{t-h}|x_0))+Cov( E(x_t|x_0),E(x_{t-h}|x_0))\\\\\n&=E(0)+Cov(x_0,x_0)=Var(x_0)=\\nu\n\\end{align}\\] e, portanto, o processo é fracamente estacionário. Contudo, \\[Var(\\bar{x})=\\frac{\\nu}{n}+\\frac{2}{n}\\sum_{h=1}^{n-1}\\left(1-\\frac{h}{n}\\right)\\nu=\\nu,\\] portanto, o erro padrão não decai com o aumento do tamanho da amostra.\n\\(\\blacksquare\\)\n\n\n\nDefinition 2.3 Uma série temporal estacionária é dita ser ergódica para a média se \\[\\sum_{i=1}^n\\frac{x_i}{n}\\stackrel{p}{\\rightarrow} \\mu,\\] quando \\(n\\rightarrow\\infty\\).\n\n\n\nExample 2.4 Considere novamente o processo no (estationario_nao_ergodico?). Como \\(\\bar{x}_n=x_0\\), tem-se que, para \\(\\varepsilon&gt;0\\) arbitrário, \\(\\bar{x}\\sim\\hbox{Normal}(0,\\nu)\\) e \\[P(|\\bar{x}_n-0|&gt;\\varepsilon)=2P(x_0&gt;\\varepsilon)=2\\int_{-\\infty}^\\varepsilon \\frac{1}{\\sqrt{2\\pi\\nu}}e^{-\\frac{y^2}{2\\nu}}dy&gt;\\frac{1}{2}\\] logo, \\(\\bar{x}\\) não converge em probabilidade para \\(0\\) e, portanto, o processo não é ergódico na média. \\(\\blacksquare\\)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Séries Estacionárias</span>"
    ]
  },
  {
    "objectID": "estacionaria.html#ruído-branco",
    "href": "estacionaria.html#ruído-branco",
    "title": "2  Séries Estacionárias",
    "section": "2.2 Ruído branco",
    "text": "2.2 Ruído branco\n\nDefinition 2.4 A série estacionária \\(x_t\\) é dita ser um ruído branco se \\(E(x_t)=0\\), \\(Var(x_t)=\\nu\\) e \\[\\begin{equation}\n        Cov(x_t,x_s)=0,\n        \\end{equation}\\] para todo \\(t\\neq s\\). \\(\\blacksquare\\)\n\nÉ imediato que o ruído branco é uma série temporal estacionária. Além disso, pela Desigualdade de Chebyshev, para qualquer \\(\\varepsilon&gt;0\\),\n\\[P\\left(|\\bar{x}_n|\\geq\\varepsilon\\right)\\leq \\frac{E(\\bar{x}_n^2)}{\\varepsilon^2}=\\frac{Var(\\bar{x}_n)}{\\varepsilon^2}=\\frac{\\nu}{n\\varepsilon^2}\\] logo \\(\\lim_{n}P(|\\bar{x}_n|\\leq \\varepsilon)=0\\) e \\(\\bar{x}_n\\stackrel{p}{\\rightarrow}0\\). Portanto, o ruído branco é ergódico.\nConsidere agora a série temporal \\(y_t=\\mu+x_t\\), onde \\(x_t\\) é um ruído branco. Então \\[\\bar{y}_n=\\mu+\\bar{x}_n\\stackrel{p}{\\rightarrow}\\mu\\] e \\(\\bar{y}_n\\) é um estimador para \\(\\mu\\).\nEm certos momentos, será considerado que \\(x_t\\) e \\(x_s\\), para todo \\(t\\neq s\\) são independentes (essa é uma condição mais forte, pois implica em \\(Cov(x_t,x_s)=0\\)). Esse processo é denominado ruído branco independente.\nPor último, também será considerado a possibilidade de que \\(x_t\\sim\\hbox{Normal}(0,\\nu)\\), com \\(x_t\\) e \\(x_s\\) indepentens para todo \\(t\\neq s\\). Esse processo será denominado é denominado ruído branco gaussiano.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Séries Estacionárias</span>"
    ]
  },
  {
    "objectID": "estacionaria.html#processo-de-média-móvel",
    "href": "estacionaria.html#processo-de-média-móvel",
    "title": "2  Séries Estacionárias",
    "section": "2.3 Processo de média móvel",
    "text": "2.3 Processo de média móvel\nSejam \\(\\ldots,\\varepsilon_{-2},\\varepsilon_{-1},\\varepsilon_{0},\\varepsilon_{1},\\ldots\\) ruídos brancos. O modelo de série temporal de média móvel de ordem \\(q\\), denotado por MA\\((q)\\) é definido como\n\\[x_t=\\varepsilon_{t}+\\sum_{j=1}^q \\theta_j\\varepsilon_{t-j}.\\] Vamos demonstrar que esse processo é estacionário. Primeiro, observe que\n\\[E(x_t)=E(\\varepsilon_t)+\\sum_{j=1}^q\\theta_jE(\\varepsilon_{t-j})=0.\\]\nDefina \\(\\theta_0=1\\). Então \\[x_t=\\sum_{j=0}^q \\theta_j\\varepsilon_{t-j},\\] e \\[Var(x_t)=\\sum_{j=0}^q\\sum_{k=0}^qCov(\\theta_j\\varepsilon_{t-j},\\theta_k\\varepsilon_{t-k})=\\nu\\sum_{j=0}^q\\theta_j^2+\\underbrace{\\sum_{j=0}^q\\sum_{j\\neq k}\\theta_j\\theta_k\\gamma(|j-k|)}_{0}=\\nu\\sum_{j=0}^q\\theta_j^2.\\] Por último, para \\(t\\neq s\\),\n\\[Cov(x_t,x_s)=\\sum_{j=0}^q\\sum_{k=0}^qCov(\\theta_j\\varepsilon_{t-j},\\theta_k\\varepsilon_{s-k})=\\sum_{j=0}^q\\sum_{k=0}^q\\theta_j\\theta_k\\gamma(|t-s-(j-k)|)\\] Como \\((j-k)\\in\\{-q,\\ldots,q\\}\\), haverá autocovariância sempre que \\(|t-s|\\leq q\\), o que implica que a \\(Cov(x_t,x_s)\\) é função de \\(|t-s|\\), o que conclui a demonstração.\n\nExample 2.5 O modelo MA(1) é dado por \\[x_t=\\varepsilon_t+\\theta\\varepsilon_{t-1}\\] Sua função de autocovariância é \\[\\gamma(h)=\\left\\{\\begin{array}{ll}\\nu(1+\\theta^2),&h=0\\\\ \\nu\\theta,&h=\\pm1,\\\\0,&\\hbox{caso contrário}\\end{array}\\right.\\]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Séries Estacionárias</span>"
    ]
  },
  {
    "objectID": "estacionaria.html#a-função-de-autocorrelação-estimada-e-o-correlograma",
    "href": "estacionaria.html#a-função-de-autocorrelação-estimada-e-o-correlograma",
    "title": "2  Séries Estacionárias",
    "section": "2.4 A função de autocorrelação estimada e o correlograma",
    "text": "2.4 A função de autocorrelação estimada e o correlograma\nConsidere uma série temporal estacionária e ergódica, com média \\(\\mu\\). Então sua função de autocovariância é dada por\n\\[\\gamma(h)=E((x_{t+h}-\\mu)(x_t-\\mu))\\] A função de autocorrelação é definida por \\[\\rho(h)=\\frac{Cov(x_{t+h},x_t)}{\\sqrt{Var(x_{t+h})Var(x_t)}}=\\frac{\\gamma(h)}{\\gamma(0)}.\\]\n\nExample 2.6 Seja \\(x_t=\\varepsilon_t\\), onde \\(\\varepsilon_t\\) é um ruído branco. Então \\[\\gamma(h)=\\left\\{\\begin{array}{ll}\\nu,&h=0,\\\\0,&\\hbox{caso contrário}\\end{array}\\right.\\] e \\[\\rho(h)=\\left\\{\\begin{array}{ll}1,&h=0,\\\\0,&\\hbox{caso contrário}\\end{array}\\right.\\]\n\n\nExample 2.7 Considere o modelo MA(1). Como \\[\\gamma(h)=\\left\\{\\begin{array}{ll}\\nu(1+\\theta^2),&h=0\\\\ \\nu\\theta,&h=\\pm1,\\\\0,&\\hbox{caso contrário}\\end{array}\\right.\\]e teremos \\[\\rho(h)=\\left\\{\\begin{array}{ll}1,&h=0\\\\ \\frac{\\theta}{1+\\theta^2},&h=\\pm1,\\\\0,&\\hbox{caso contrário}\\end{array}\\right.\\]\n\nPara uma série observada de tamanho \\(n\\), pode-se estimar \\(\\gamma(h)\\) pelo método da substituição:\n\\[\\begin{align}\n                        \\widehat{\\gamma(h)}&=\\frac{1}{n}\\sum_{i=1}^{n-h}\\left(x_{i+h} - \\bar{x}\\right)\\left(x_{i} - \\bar{x}\\right)\n                        \\end{align}\\]\ne \\(\\rho\\) por\n\\[\\begin{equation}\n        \\hat{\\rho}(h)=\\frac{\\hat{\\gamma}(h)}{\\hat{\\gamma}(0)}\n        \\end{equation}\\]\nO correlograma é um gráfico cartesiano construído a partir dos pontos \\((h, \\hat{\\rho}(h))\\). A partir de cada ponto é desenhada uma linha, semelhante a um gráfico de barras. Ao se observer um ruído branco, espera-se que o correlograma apresente valores pequenos para todo \\(h&gt;0\\), enquanto que para um modelo MA(\\(q\\)), os pontos \\((1, \\hat{\\rho}(1)),\\ldots,(q, \\hat{\\rho}(q))\\) devem ser expressivamente diferentes de zero.\nComo \\(\\hat{\\rho}(0)=1\\), a implementação desta função em softwares estatísticos pode variar. Por exemplo, a função acf do pacote stats começa na defasagem 0, apresentando portanto uma linha no ponto (0,\\(\\hat{\\rho}(0)\\))=(0,1). Já a função Acf do pacote forecast (ou ainda a acf do pacote TSA) começam na defasagem \\(h=1\\).\n\nExample 2.8 A série abaixo representa o número anual de óbitos por afogamento na cidade de Manaus, entre 1996 e 2021. Os dados foram obtidos do Ministério da Saúde (http://tabnet.datasus.gov.br/), considerando o código internacional de doenças (CID10) W70 - Afogamento e submersão conseqüentes a queda dentro de águas naturais.\n\nurl &lt;- 'https://docs.google.com/spreadsheets/d/13MdzvZB5U85MkLy97ZRytkylikJu7rJoC1WL0XjKw-c/edit?usp=sharing'\nrequire(gsheet)\n\nCarregando pacotes exigidos: gsheet\n\ndados &lt;-gsheet2tbl(url)\nafogamentos &lt;- ts( dados[,2], start = 1996)\n\nts.plot(afogamentos, lwd = 2, main = '', xlab = 'Ano', ylab = 'No. óbitos por afogamento')\n\n\n\n\n\n\nNúmero anual de óbitos por afogamento em Manaus.\n\n\n\n\n\nA figura abaixo mostra o correlograma dessa série. Observe que as autocorrelações amostrais observadas são baixas. Esse tipo de comportamento é esperado em um ruído branco. Como a série não oscila em torno de zero, um modelo razoável seria \\[y_t=\\mu+\\varepsilon_t,\\] onde \\(\\varepsilon_t\\) é um ruído branco. Nesse caso, \\(\\bar{y}_n=1,88\\) é uma estimativa para \\(\\mu\\).\nacf(afogamentos, lwd = 2, main = '', xlab = 'Defasagem', ylab = 'Autocorrelação')\n\n\n\n\n\n\n\n\n\nFigure 2.1: Correlograma para o número anual de óbitos por afogamento em Manaus.\n\n\n\n\n\n\n\\(\\blacksquare\\)\n\nSem perda de generalidade, assuma que \\(x_t\\) é um processo estacionário com \\(\\mu=0\\). Para uma defasagem \\(h&gt;0\\), considere a hipótese \\(H_0:\\rho(h)=0\\). Sob \\(H_0\\), o processo estacionário é um ruído branco e a distribuição da função de autocorrelação amostral é \\(N(0,1/n)\\). Portanto, uma região de rejeição ao nível de 5% de significância para um teste baseado nessa distribuição é\n\\[R={\\hat{\\rho}(h): \\hat{\\rho}(h)|&gt;\\frac{2}{\\sqrt{n}},\\] Este é o valor da linha pontilhada que aparece no correlograma na Figure 2.1.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Séries Estacionárias</span>"
    ]
  },
  {
    "objectID": "estacionaria.html#testes-para-a-autocorrelação",
    "href": "estacionaria.html#testes-para-a-autocorrelação",
    "title": "2  Séries Estacionárias",
    "section": "2.5 Testes para a autocorrelação",
    "text": "2.5 Testes para a autocorrelação\nNa seção anterior mostrou-se como testar se \\(\\rho(h)=0\\), para um \\(h\\) fixado. Como várias autocorrelações para diferentes defasagens são avaliadas simultaneamente, o correto seria testar \\(H_0: \\rho(h)=0\\;\\;\\forall h=1,\\ldots,q\\), onde \\(q\\) é o valor máximo da defasagem a ser testado. Considerando a região de rejeição dada anteriormente, pela desigualdade de Bonferroni,\n\\[\\begin{align}P(\\hbox{Rejeitar }H_0|H_0\\hbox{ é verdadeira})&=P\\left(\\cup_{h=1}^q\\left\\{ \\hat{\\rho}(h)&gt;\\frac{2}{\\sqrt{n}}\\right\\}| H_0\\hbox{ é verdade}\\right)\\\\\n&\\leq \\sum_{h=1}^qP\\left( \\hat{\\rho}(h)&gt;\\frac{2}{\\sqrt{n}}| H_0\\hbox{ é verdade}\\right)\\\\ &&lt;q\\alpha\\end{align}\\]\nPortanto, a probabilidade de cometer o erro tipo 1 pode aumentar na medida em que testamos mais de uma defasagem.\nContudo, se todas as autocorrelações, de defasagens 1 até \\(q\\), são baixas, não há evidências contra \\(H_0\\). Com esse espírito o teste de Ljung-Box (1978) utiliza a estatística \\[Q_{LB}=n(n+2)\\sum_{h=1}^q \\frac{\\hat{\\rho}(h)^2}{n-h}\\] e rejeita \\(H_0\\) se \\(Q_{LB}&gt;\\chi^2_{1-\\alpha,q}\\), onde \\(\\chi^2_{\\lambda,n}\\) é o quantil \\(\\lambda\\) da distribuição \\(\\chi^2_n\\).\nO teste de Box-Pierce (1970) possui o mesmo objetivo e tem a mesma regra de decisão, mudando apenas a estatística de teste para\n\\[Q_{BP}=n\\sum_{h=1}^q \\frac{\\hat{\\rho}(h)^2}{n-h}.\\]\n\nExample 2.9 Para a série de óbitos anuais por afogamentos em Manaus, tem-se que os teste Ljung-Box e Box-Pierce não rejeitam a hipótese de ruído branco.\n\nBox.test(afogamentos, type = 'Ljung-Box')\n\n\n    Box-Ljung test\n\ndata:  afogamentos\nX-squared = 1.2623, df = 1, p-value = 0.2612\n\nBox.test(afogamentos, type = 'Box-Pierce')\n\n\n    Box-Pierce test\n\ndata:  afogamentos\nX-squared = 1.127, df = 1, p-value = 0.2884\n\n\n\\(\\blacksquare\\)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Séries Estacionárias</span>"
    ]
  },
  {
    "objectID": "sinal.html",
    "href": "sinal.html",
    "title": "3  Sinal e ruído",
    "section": "",
    "text": "3.1 Sinal e ruído\nEm geral, a série temporal possui componentes de dois tipos: sinal e ruído. O primeiro é uma função do tempo geralmente relacionado com a média da série em dado instante de tempo, enquanto que o segundo está relacionado com a variância. Podemos assumir que essa relação é aditiva:\n\\[X_t=\\hbox{sinal}(t)+\\varepsilon_t\\] onde \\(\\varepsilon_t\\) é o ruído.\nEm alguns casos essa relação é multiplicativa, ou seja,\n\\[X_t=\\exp\\{\\hbox{sinal}(t)+\\varepsilon_t\\},\\] e, nesses casos, aplicamos o logaritmo na série para que as componentes se tornem aditivas.\nOs sinais mais importantes são:\n\\[x_t=A\\cos\\left(\\phi+\\frac{2\\pi}{p}t\\right)+\\varepsilon_t\\] onde \\(p\\) é o período sazonal, \\(A\\) é amplitude da onda e \\(\\phi\\) a fase.\nOs padrões oscilatórios (sazonalidade e ciclos) descritos acima variam em torno de zero. Caso seja necessário, um parâmetro \\(\\mu\\) constante pode ser adicionado para caracterizar uma oscilação em torno de uma média.\nÉ possível que uma série possua todos os sinais acima, sendo escrita como\n\\[x_t=\\sum_{j=0}^q \\beta_j t^j+A\\cos\\left(\\phi+2\\pi\\lambda t\\right)+A_t\\cos\\left(\\phi_t+2\\pi\\lambda t\\right)+\\varepsilon_t\\]\nO ruído é a parte aleatória da composição e possui média zero. Isso implica que, para uma série com sinal \\(f(t)\\), teremos\n\\[E(x_t)=E(f(t))+E(\\varepsilon_t)=f(t)\\] e \\[Var(x_t)=Var(f(t)+\\varepsilon_t)=Var(\\varepsilon_t)\\] Os ruídos mais importantes são:\nA série a seguir representa uma série mensal de concentração de \\(\\hbox{CO}_2\\) na atmosfera em Mauna Loa, expressa em partes por milhão. Note o comportamento da tendência e da sazonalidade.\nplot(co2)\nExistem diversas ferramentas que estimam a tendência e a sazonalidade. Dentre estas, detaca-se o STL, por sua robustez. Abaixo, ilustramos a decomposição da série co2. O termo remainder, também conhecido como resíduo, é calculado como\n\\[e_t=x_t-\\hat{f}(t),\\] onde \\(\\hat{f}(t)\\) é o sinal (tendência+sazonalidade) ajustado. Se não houver qualquer outro sinal a ser ajustado, então \\(e_t\\) é uma estimativa para \\(\\varepsilon_t\\).\n# p é o período do padrão sazonal\np = 12\nplot(stl(co2,p))",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Sinal e ruído</span>"
    ]
  },
  {
    "objectID": "sinal.html#sinal-e-ruído",
    "href": "sinal.html#sinal-e-ruído",
    "title": "3  Sinal e ruído",
    "section": "",
    "text": "Tendência: um comportamento de subida ou descida que pode ser observado no médio/longo prazo. Uma série temporal com tendência costuma ser bem representada por polinômios, ou seja \\[x_t= \\sum_{j=0}^q\\beta_j t^j +\\varepsilon_t.\\]\nSazonalidade: é um padrão de oscilação que ocorre em um período fixo e conhecido. Cheias de rios e quantidade de chuva são exemplos de padrões sazonais. Em termos gerais, o padrão sazonal pode ser representado por um harmônico, ou seja,\n\n\n\nCiclos: é um padrão oscilatório sem período fixo, como o ciclo de recessão de uma economia. Modelar ciclos é um pouco mais complexo, mas veremos posteriormente que é possível escrever séries deste tipo como \\[x_t=A_t\\cos\\left(\\phi_t+2\\pi\\lambda t\\right)+\\varepsilon_t,\\] onde a amplitude e a fase variam no tempo e o período \\(1/\\lambda\\) é desconhecido.\n\n\n\n\n\n\n\nRuído branco: como ja definido, é um processo estacionário com variância constante e não correlacionado, ou seja \\(Cov(\\varepsilon_t,\\varepsilon_s)=0\\) para todo \\(t\\neq s\\).\nMédia móvel de ordem \\(q\\): sejam \\(\\ldots,\\varepsilon_{-2},\\varepsilon_{-1},\\varepsilon_{0},\\varepsilon_{1},\\ldots\\) ruídos brancos. O ruído de média móvel de ordem \\(q\\) é dado por \\[\\eta_t=\\varepsilon_{t}+\\sum_{j=1}^q \\theta_j\\varepsilon_{t-j}.\\]\n\n\n\n\n\n\n\nExercício. Considere a série AirPassengers, disponível no pacote datasets.\n\nFaça um gráfico da série temporal e procure determinar suas componentes.\nA função decompose estima a sazonalidade assumindo a média das observações correspodentes ao mesmo fator sazonal (por exemplo, todos os janeiros). Faça um gráfico do resultado do decompose para esta série e discuta os resultados (em especial o termo random, que é o resíduo da decomposição).\nRepita o item 2, mas utilizando a função stl. Quais são as principais diferenças?\nAplique o logaritmo da série e verifique o seu gráfico. Quais são as semelhanças e diferenças deste gráfico com o obtido no item 1?\n\n\n\nExercício. Na série abaixo temos a taxa de desemprego mensal no Brasil entre março de 2002 e dezembro de 2015. Analise as componentes desta série.\n\nurl &lt;- 'https://www.dropbox.com/s/rmgymzsic99qawd/desemprego.csv?dl=1'\nbanco &lt;- read.csv(url, sep = ';', h = F)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Sinal e ruído</span>"
    ]
  },
  {
    "objectID": "sinal.html#a-função-de-aucorrelação-para-diferentes-sinais",
    "href": "sinal.html#a-função-de-aucorrelação-para-diferentes-sinais",
    "title": "3  Sinal e ruído",
    "section": "3.2 A função de aucorrelação para diferentes sinais",
    "text": "3.2 A função de aucorrelação para diferentes sinais\nQuando a amostra é aleatória, a função de autocorrelação é nula para qualquer defasagem diferente de 0. Deste modo, o correlograma deve apresentar valores próximos de zero.\nPara entender o que próximo de zero significa, o limites do intervalo de confiança para o coeficiente de correlação sobre a hipótese de que esta é nula são colocados no gráfico.\nAbaixo ilustramos um correlograma para uma amostra de variáveis aleatórias independentes com distribuição normal padrão.\n\nx &lt;- rnorm(120)\n\n# correlograma\nacf(x)\n\n\n\n\n\n\n\n# o mesmo correlograma com uma defasagem maior\nacf(x, lag = 50)\n\n\n\n\n\n\n\n\nConsidere que a série exibe tendência. Isso implica que a relação entre \\(x_t\\) e \\(x_{t+h}\\) é aproximadamente linear na vizinhança de \\(t\\), ou seja\n\\[x_{t+h}\\approx x_t+hb+\\varepsilon_{t}\\] Isso implica em \\(Corr(x_t,x_{t+h})\\approx 1\\). Por ser um comportamento de médio/longo prazo, é esperado que \\(\\rho(h)\\) decaia lentamente para zero. Considere, por exemplo, a série\n\\[x_t= t + \\varepsilon_t,\\] onde \\(\\varepsilon_t\\sim\\hbox{Normal}(0,5^2)\\). Abaixo simulamos essa série e apresentamos o respectivo correlograma\n\nx &lt;- rnorm(100, 1:100, 5)\n\noo &lt;- par( mfrow=c(1,2))\nts.plot(x)\nacf(x, lag = 50)\n\n\n\n\n\n\n\npar(oo)\n\nObserve as similaridades do correlograma acima com o observado para a série de homicídios em Manaus, vista anteriormente.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nO sinal sazonal é caracterizado por um comportamento periódico, geralmente modelado pela função harmônica:\n\\[\\hbox{sinal}(t)=A\\cos\\left(\\frac{2\\pi}{p}t + \\phi\\right)\\]\nVamos estudar a função harmônica com mais detalhes em outro momento. Por hora, note que\n\\[\\begin{align}\nx_{t+h}&=A\\cos\\left(\\frac{2\\pi}{p}(t+h) + \\phi\\right)+\\varepsilon_{t+h}=A\\cos\\left(\\frac{2\\pi}{p}t+ \\frac{2\\pi}{p}h+ \\phi\\right)+\\varepsilon_{t+h}\\\\\n&=A\\cos\\left(\\frac{2\\pi}{p}t+\\phi\\right)\\cos\\left( \\frac{2\\pi}{p}h\\right)-A\\sin\\left(\\frac{2\\pi}{p}t+\\phi\\right)\\sin\\left( \\frac{2\\pi}{p}h\\right)+\\varepsilon_{t+h}\\\\\n&=\\left[A\\cos\\left(\\frac{2\\pi}{p}t+\\phi\\right)\\pm\\varepsilon_t\\right]\\cos\\left( \\frac{2\\pi}{p}h\\right)-A\\sin\\left(\\frac{2\\pi}{p}t+\\phi\\right)\\sin\\left( \\frac{2\\pi}{p}h\\right)+\\varepsilon_{t+h}\\\\\n&=\\underbrace{\\cos\\left( \\frac{2\\pi}{p}h\\right)}_{A(h)}x_t-\\underbrace{A\\sin\\left(\\frac{2\\pi}{p}t+\\phi\\right)\\sin\\left( \\frac{2\\pi}{p}h\\right)}_{B(h)}+\\underbrace{\\varepsilon_{t+h}-A\\cos\\left( \\frac{2\\pi}{p}h\\right)\\varepsilon_t}_{\\varepsilon_{t+h}^\\star}\n\\end{align}\\] ou seja, \\[x_{t+h}\\approx A(h)x_t+B(h)+\\varepsilon_{t+h}^\\star,\\] e \\(x_{t+h}\\) e \\(x_t\\) são correlacionados quando \\(A(h)\\neq 0\\). Como \\(|A(h)|\\) oscila entre 0 e 1, a função e autocorrelação deve ter um comportamento de onda, atingindo seu máximo em \\(h=p,2p,3p,\\ldots\\). Observe a série simulada abaixo, com um período \\(p=12\\)\n\nset.seed(123)\noo &lt;- par( mfrow = c(1,2))\nfor(i in 1:100) x[i] &lt;- cos(2*pi*i/12) + rnorm(1,0,.05)\nts.plot(x)\nacf(x, lag = 36)\n\n\n\n\n\n\n\npar(oo)\n\nCompare esse correlograma com a série mensal de temperaturas no castelo de Nottingham\n\nplot(nottem)\n\n\n\n\n\n\n\nacf(nottem, lag = 36)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Sinal e ruído</span>"
    ]
  },
  {
    "objectID": "sinal.html#exercícios",
    "href": "sinal.html#exercícios",
    "title": "3  Sinal e ruído",
    "section": "3.3 Exercícios",
    "text": "3.3 Exercícios\n\nExercício 1 Estude o comportamento da série ldeaths, que conta o número mensal de óbitos por doenças pulmonares no Reino Unido.\n\n\nExercício 2 Estude o comportamento da série do número de óbitos maternos mensais.\n\n\nExercício 3 Em 2017, um epidemiologista estava interessado na série de suicídios no Mato Grosso do Sul. O banco de dados utilizado é dado a seguir. Construa uma série mensal e estude seu comportamento\n\nurl &lt;- 'https://drive.google.com/uc?authuser=0&id=1DMSgrQDl0636Lw0Y0MYJHJrgw_2uXntM&export=download'",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Sinal e ruído</span>"
    ]
  },
  {
    "objectID": "modelo_linear.html",
    "href": "modelo_linear.html",
    "title": "4  Revisão sobre o modelo linear",
    "section": "",
    "text": "4.1 A distribuição normal\nDizemos que o vetor \\(\\boldsymbol{x}\\), de comprimento \\(n\\), tem distribuição normal (multivariada) se sua função densidade é dada por\n\\[f(x|\\mu,\\Phi) = |2\\pi\\Sigma|^{\\frac{n}{2}}\\exp\\left\\{-\\frac{1}{2}(\\boldsymbol{x}-\\boldsymbol{\\mu})'\\Sigma^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu})\\right\\}\\] onde \\(\\boldsymbol{\\mu}\\) é um vetor de comprimento \\(n\\) e \\(\\Sigma\\) é a matriz de covariâncias. Para essa distribuição, \\(E(\\boldsymbol{x}) = \\boldsymbol{\\mu}\\) e \\(Var(\\boldsymbol{x}) =\\Sigma\\).\nSe \\(\\boldsymbol{x}|\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma} ∼ \\hbox{Normal}_n(\\boldsymbol{\\mu}, \\Sigma )\\), então, para qualquer matriz (real) \\(\\boldsymbol{A}\\) de dimensão \\(m\\times n\\) e para qualquer vetor \\(\\boldsymbol{b}\\) de comprimento \\(n\\),\n\\[\\boldsymbol{Ax} + \\boldsymbol{b} ∼ \\hbox{Normal}_m(\\boldsymbol{A}\\boldsymbol{\\mu} + \\boldsymbol{b}, \\boldsymbol{A}\\Sigma\\boldsymbol{A}).\\] Em particular, \\(\\boldsymbol{z} = \\Sigma^{-1/2}(\\boldsymbol{x} − \\boldsymbol{\\mu})\\) tem distribuição Normal\\((\\boldsymbol{0}, \\boldsymbol{I})\\).\nConsidere que o vetor \\(\\boldsymbol{x}\\) foi particionado em \\(\\boldsymbol{x} = (\\boldsymbol{x}_1, \\boldsymbol{x}_2)\\), onde \\(\\boldsymbol{x}_1\\) tem comprimento \\(q &lt; n\\) e \\(x_2\\) tem comprimento \\(n − q\\). Os parâmetros da distribuição podem ser particionados da seguinte forma\n\\[\\left(\\begin{array}{c}\\boldsymbol{x}_1\\\\ \\boldsymbol{x}_2\\end{array}\\right)\n\\sim\\hbox{Normal}_n\\left[\n\\left(\\begin{array}{c}\\boldsymbol{\\mu}_1 \\\\ \\boldsymbol{\\mu}_2\\end{array}\\right),\n\\left(\\begin{array}{cc}\\Sigma_{11} & \\Sigma_{12} \\\\ \\Sigma_{12}' & \\Sigma_{22} \\end{array}\\right)\\right]\\] Então \\(\\boldsymbol{x}_1 \\sim \\hbox{Normal}(\\boldsymbol{\\mu}_1, \\Sigma_{11})\\) e \\(\\boldsymbol{x}_2 \\sim\\hbox{Normal}(\\boldsymbol{\\mu}_2, \\Sigma_{22})\\). Além disso \\(Cov(\\boldsymbol{x}_1, \\boldsymbol{x}_2) = \\Sigma_{12}\\) e \\(Cov(\\boldsymbol{x}_2, \\boldsymbol{x}_1) = \\Sigma_{12}'\\). Além disso,\n\\[\\boldsymbol{x}_2|\\boldsymbol{x}_1\\sim\\hbox{Normal}(\\boldsymbol{\\mu}_2+\\Sigma_{12}'\\Sigma_{11}^{-1}(\\boldsymbol{x}_1-\\boldsymbol{\\mu}), \\Sigma_{22}-\\Sigma_{12}'\\Sigma_{11}^{-1}\\Sigma_{12})\\] Também é possível rescontruiar a conjunta quando temos a condicional e a marginal, conforme mostra o lema abaixo.\n.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Revisão sobre o modelo linear</span>"
    ]
  },
  {
    "objectID": "modelo_linear.html#a-distribuição-normal",
    "href": "modelo_linear.html#a-distribuição-normal",
    "title": "4  Revisão sobre o modelo linear",
    "section": "",
    "text": "Lema (Reconstrução da conjunta) Se \\(\\boldsymbol{x}_2|\\boldsymbol{x}_1\\sim\\hbox{Normal}(\\boldsymbol{\\mu}_2+\\boldsymbol{B}_1(\\boldsymbol{x}_1-\\boldsymbol{\\mu}_1),\\boldsymbol{B}_2)\\) e \\(\\boldsymbol{x}_1\\sim\\hbox{Normal}(\\boldsymbol{\\mu}_1,\\Sigma_{11})\\), então,\n\\[\\left(\\begin{array}{c}\\boldsymbol{x}_1\\\\\\boldsymbol{x}_2\\end{array}\\right)\\sim\\hbox{Normal}_n\\left[\\left(\\begin{array}{c}\\boldsymbol{\\mu}_1 \\\\ \\boldsymbol{\\mu}_2\\end{array}\\right),\\left(\\begin{array}{cc}\\Sigma_{11} & \\Sigma_{11}\\boldsymbol{B}_1' \\\\ \\boldsymbol{B}_1\\Sigma_{11} & \\boldsymbol{B}_2+\\boldsymbol{B}_1\\Sigma_{11}\\boldsymbol{B}_1'\\end{array} \\right)\\right]\\]",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Revisão sobre o modelo linear</span>"
    ]
  },
  {
    "objectID": "modelo_linear.html#o-modelo-linear",
    "href": "modelo_linear.html#o-modelo-linear",
    "title": "4  Revisão sobre o modelo linear",
    "section": "4.2 O modelo linear",
    "text": "4.2 O modelo linear\nPara \\(i=1,\\ldots,n\\), considere o modelo linear abaixo: \\[y_i= \\beta_0+\\sum_{j=1}^{p-1}x_{i,j}+\\varepsilon_i=\\underbrace{ \\left(1\\;\\;x_{i,1}\\;\\;\\cdots\\;\\;x_{i,p-1}\\right)}_\\text{$\\boldsymbol{f}'_i$}\\underbrace{\\left(\\begin{array}{c}\\beta_0 \\\\ \\beta_1 \\\\ \\vdots \\\\ \\beta_{p-1}\n        \\end{array}\\right)}_\\text{$\\boldsymbol{\\beta}$}+\\varepsilon_i=\\boldsymbol{f}'_i\\boldsymbol{\\beta}+\\varepsilon_i,\\] onde \\(x_i\\) é fixado e \\(\\varepsilon\\) é um ruído branco gaussiano. Pela independência entre \\(y_i\\) e \\(y_j\\), pode-se fazer a seguinte representação estocástica de \\(\\boldsymbol{y}\\): \\[\\begin{equation}\n        \\boldsymbol{y}=\\boldsymbol{F}'\\boldsymbol{\\beta} + \\boldsymbol{\\varepsilon},\n        \\end{equation}\\] onde \\(\\boldsymbol{\\varepsilon}\\sim\\hbox{Normal}(\\boldsymbol{0},\\nu\\textbf{I}_n)\\) e \\(\\boldsymbol{F}\\) é uma matriz \\(p\\times n\\) conhecida com \\(i\\)-ésima coluna dada por \\(\\boldsymbol{f}_i\\):\n\\[\\boldsymbol{F}=\\left(\\boldsymbol{f}_1,\\ldots,\\boldsymbol{f}_n\\right).\\] Disto, tem-se que \\[\\boldsymbol{y}|\\boldsymbol{\\beta},\\nu\\sim\\hbox{Normal}(\\boldsymbol{F}'\\boldsymbol{\\beta},\\nu\\textbf{I}_n)\\]\n\n4.2.0.1 Priori conjugada\nConsidere que \\(\\nu\\) é conhecido. Então, a priori \\(\\boldsymbol{\\beta}\\sim\\hbox{Normal}(\\boldsymbol{m},\\nu\\boldsymbol{C})\\) é conjugada para o modelo linear.\nPelo lema da reconstrução da conjunta, temos que\n\\[\\left(\\begin{array}{c}\\boldsymbol{\\beta}\\\\\\boldsymbol{y} \\end{array}\\right)\\sim\\hbox{Normal}\\left[\\left(\\begin{array}{c}  \\boldsymbol{m}\\\\ \\boldsymbol{F}'\\boldsymbol{m} \\end{array}\\right),\\left(\\begin{array}{cc} \\nu \\boldsymbol{C} &  \\nu\\boldsymbol{C}\\boldsymbol{F}\\\\ \\nu\\boldsymbol{F}'\\boldsymbol{C} & \\nu[\\textbf{I}+\\boldsymbol{F}'\\boldsymbol{C}\\boldsymbol{F}] \\end{array} \\right)\\right]\\] logo, a posteriori é dada por \\[\\boldsymbol{\\beta}|\\boldsymbol{y}\\sim\\hbox{Normal}(\\boldsymbol{m}+A(\\boldsymbol{y}-\\boldsymbol{F}'\\boldsymbol{m}), \\nu[\\boldsymbol{I}-\\boldsymbol{A}(\\boldsymbol{I}+\\boldsymbol{F}'\\boldsymbol{C}\\boldsymbol{F})\\boldsymbol{A}'])\\] onde \\(\\boldsymbol{A}=\\boldsymbol{CF}(\\boldsymbol{I}+\\boldsymbol{F}'\\boldsymbol{C}\\boldsymbol{F})^{-1}\\).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Revisão sobre o modelo linear</span>"
    ]
  },
  {
    "objectID": "modelo_linear.html#o-uso-de-modelos-de-regressão-na-estimação-de-tendência",
    "href": "modelo_linear.html#o-uso-de-modelos-de-regressão-na-estimação-de-tendência",
    "title": "4  Revisão sobre o modelo linear",
    "section": "4.3 O uso de modelos de regressão na estimação de tendência",
    "text": "4.3 O uso de modelos de regressão na estimação de tendência\nPor algum tempo, modelos de regressão foram muito utilizados na estimação dos sinais de tendência e sazonalidade.\nConsidere que a tendência é definida como uma função \\(T:(0,t]\\rightarrow \\mathbb{R}\\). O Teorema de Weierstrass afirma que, se \\(T\\) é contínua, então para qualquer \\(\\delta&gt;0\\), existe um polinômio \\(u(.)\\) tal que \\[|T(t)-u(t)|&lt;\\delta.\\] Isto quer dizer que \\(T(.)\\) sempre pode ser aproximada por um polinômio. Assim, para determinada ordem \\(p\\), é correto afirmar que\n\\[\\begin{equation}\n        y_t = \\beta_0 + \\sum_{j=1}^p \\beta_j t^j + \\varepsilon_t\n        \\end{equation}\\] onde \\(\\varepsilon_t\\) é um ruído estacionário, é um modelo razoável para uma série temporal com tendência. Assumindo que \\(\\varepsilon_t\\) é um ruído branco gaussiano, tem-se o modelo de tendência polinomial de grau \\(p\\).\nFazendo \\(\\boldsymbol{f}_t'=(1,t,\\ldots,t^p)\\) , o modelo de tendência polinomial é reescrito como \\[\\boldsymbol{y}=\\boldsymbol{F}'\\boldsymbol{\\beta}+\\boldsymbol{\\varepsilon}\\] Para ilustrar a estimação da tendência, vamos utilizar a série sobre o PIB anual brasileiro, observada entre 1977 e 2016, que pode ser baixada com os comandos abaixo.\n\n        x &lt;- read.csv(\"https://www.dropbox.com/s/zsoxpzpzqo6reml/PIB_brasil.csv?dl=1\",\n        sep=\";\",dec=\",\")\n        \n        PIB &lt;- x$PIB\n        PIB &lt;- ts(PIB, start=1967, frequency=1)\n        plot(PIB, lwd = 2, xlab = 'Ano', ylab = 'PIB (em milhares de dólares)', main = '')\n\n\n\n\n\n\n\n\nVamos implementar a matriz de regressão \\(\\boldsymbol{F}'\\) para \\(p=8\\)\n\np &lt;- 8\nn &lt;- length(PIB)\n        \nZ &lt;- model.matrix( ~ poly(time(PIB), p) )\nFt &lt;- t(Z)\n\nConsidere a prior \\(\\beta\\sim\\hbox{Normal}(\\textbf{0},\\nu lambda_0 \\boldsymbol{I})\\), com \\(\\lambda_0=10\\). A média da posteriori será\n\nlambda0= 10\nC &lt;- diag(lambda0,p+1)\nA &lt;- C%*%Ft%*%solve(( diag(1,n)+t(Ft) %*% C %*% Ft) )\n\nbeta_post &lt;- A %*% PIB\n(beta_post)\n\n            [,1]\n [1,]  6429.4617\n [2,]  9123.2037\n [3,]  -391.2442\n [4,]  2440.6759\n [5,] -1333.3176\n [6,]  -902.7895\n [7,]  -365.5307\n [8,]  -863.5817\n [9,]   122.1578\n\n\nA tendência estimada é dada pelos valores ajustados: \\[\\hat{y}=\\boldsymbol{F}'E(\\boldsymbol{\\beta}|\\boldsymbol{y})\\]\n\nts.plot(PIB)\ntend &lt;- t(Ft)%*%beta_post\nlines( ts(tend, start=1967),col=2)\n\n\n\n\n\n\n\n\nO resíduo dado por \\(\\boldsymbol{y}-\\hat{\\\\boldsymbol{y}}\\) é uma estimativa para o ruído. Abaixo, temos os seu gráfico e seu correlograma.\n\nerro = PIB - tend\nts.plot(erro)\nabline(h = 0, lty = 2)\n\n\n\n\n\n\n\nacf(erro)\n\n\n\n\n\n\n\n\nOs resíduos mostram que relações residuais do ano anterior poderia melhorar a estimativa.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Revisão sobre o modelo linear</span>"
    ]
  },
  {
    "objectID": "modelo_linear.html#exercícios",
    "href": "modelo_linear.html#exercícios",
    "title": "4  Revisão sobre o modelo linear",
    "section": "4.4 Exercícios",
    "text": "4.4 Exercícios\n\nExercício 1 Os dados abaixo representam os óbitod por suicídios no Mato Grosso do Sul. O banco de dados utilizado é dado a seguir. Construa uma série mensal e estude seu comportamento\n\nurl &lt;- 'https://drive.google.com/uc?authuser=0&id=1DMSgrQDl0636Lw0Y0MYJHJrgw_2uXntM&export=download'\n\nEstime a tendência utilizando um modelo linear.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Revisão sobre o modelo linear</span>"
    ]
  },
  {
    "objectID": "mld.html",
    "href": "mld.html",
    "title": "5  O modelo linear dinâmico",
    "section": "",
    "text": "5.1 O modelo linear dinâmico\nSeja \\(y_1,\\ldots,t\\) uma série temporal. Seja \\(D_j={y_1,\\ldots,y_j}\\). Dizemos que \\(y_t\\) é um modelo linear dinâmico se\n\\[\\begin{align}\ny_t|\\boldsymbol{\\theta}_t,D_{t-1}&\\sim\\hbox{Normal}(\\boldsymbol{F}_t'\\boldsymbol{\\theta}_t,V_t)\\\\\n\\boldsymbol{\\theta}_t|\\boldsymbol{\\theta}_{t-1},D_{t-1}&\\sim\\hbox{Normal}(\\boldsymbol{G}_t\\boldsymbol{\\theta}_{t-1},\\boldsymbol{W}_t)\n\\end{align}\\]\nA expressão acima, os \\(\\theta\\)’s são denominados estados. Para a completa especificação do modelo, devemos informar valores iniciais \\(m_0\\) e \\(C_0\\) que representam nossa opinião sobre os estados antes do tempo \\(1\\):\n\\[\\theta_0\\sim\\ N(m_0,C_0)\\] Escolhas diferentes para \\(\\boldsymbol{F}_t\\) e \\(\\boldsymbol{G}_t\\) permitem acomodar sinais diferentes.\nPode-se mostrar que \\(y_{t+h}|D_t\\) tem distribuição normal. Como \\(t+h\\) é um tempo não observado, essa é a distribuição para previsões. Neste caso, a função de previsão para o horizonte \\(h\\) é\n\\[f_t(h)=E(Y_{t+h}|D_{t})\\] onde \\(E(.)\\) sempre deve ser lido como média.\nO pacote para lidar com modelos lineares dinâmicos é o dlm. A função abaixo é utilizada para estimar as variâncias desconhecidas do modelo e deve sempre ser colocada no environment do R:\nrequire(dlm)\n\nCarregando pacotes exigidos: dlm\n\nmodFim &lt;- function(y,mod){\n  ffbs &lt;- dlmGibbsDIG(y, mod = mod, n.sample = 5000,\n                    a.y=1,b.y=100,a.theta=1,b.theta=100,\n                    save.states = FALSE, thin = 0)\n\nv_sim  &lt;- sample(ffbs$dV[-(1:2500)],2500,T)\n\nq &lt;- dim(ffbs$dW)[2]\nw_sim &lt;- NULL\nfor(j in 1:q){\n w_sim &lt;- c(w_sim, mean(sample(ffbs$dW[,j][-(1:2500)],2500,T)))\n}\n# declarando as variâncias na quádrupla\nmod$V &lt;- mean(v_sim)\nmod$W &lt;- diag( w_sim)\nreturn(mod)\n}\nTambém pode-se mostrar que \\(\\theta_{t-h}|D_t\\) tem distribuição normal. Como se trata da distribuição dos estados após verificar toda a série temporal, esta é a distribuição para a suavização.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>O modelo linear dinâmico</span>"
    ]
  }
]